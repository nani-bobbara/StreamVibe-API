-- =================================================================================
-- STREAMVIBE CONSOLIDATED SCHEMA v4.0
-- =================================================================================
-- 
-- AUTO-GENERATED: This file was generated by concatenating 7 modular schema files
-- Source: database/schema/000_base_core.sql through 006_async_infrastructure.sql
-- Generation Date: November 8, 2025
-- 
-- âš ï¸  WARNING: This is a CONSOLIDATED schema for fast production deployment.
-- For DEVELOPMENT, use the modular schema files in database/schema/ directory.
-- See database/schema/README.md for testing workflow and module-by-module deployment.
-- 
-- DEPLOYMENT MODES:
--   - Production (Initial): Use this consolidated file for fast initial setup
--   - Development/Testing: Use modular files (000-006) in database/schema/
--   - Production (Updates): Use timestamped migrations in database/migrations/
-- 
-- STATISTICS:
--   - Total Tables: 38
--   - Total Functions: 33+
--   - Total Indexes: 80+
--   - Total RLS Policies: 38+
--   - Total Enums: 4
-- 
-- MODULES INCLUDED:
--   000 - Base Core (users, subscriptions, quotas)
--   001 - Platform Connections (OAuth, social accounts)
--   002 - Content Management (content storage, search)
--   003 - AI Integration (AI providers, suggestions, usage)
--   004 - SEO Integration (search engines, submissions)
--   005 - Discovery Platform (categories, tags, trending)
--   006 - Async Infrastructure (job queue, webhooks, caching)
-- 
-- =================================================================================

-- =================================================================================
-- MODULE 000: BASE CORE SCHEMA
-- =================================================================================
-- Purpose: Foundation tables for authentication, users, subscriptions, and billing
-- Dependencies: None (this is the base module)
-- Testing: Verify user creation, subscription assignment, role management
-- Date: November 8, 2025
-- 
-- Tables Created:
--   - Enums: visibility_enum, app_role_enum, notification_type_enum, action_mode_enum
--   - Lookup: subscription_tier, subscription_status
--   - Core: users, user_role, user_setting, subscription
--   - Tracking: notification, audit_log, quota_usage_history, cache_store
-- 
-- Functions: check_quota, increment_quota, decrement_quota, has_role
-- =================================================================================

-- =================================================================================
-- SECTION 1: ENUMS (Core immutable types)
-- =================================================================================

CREATE TYPE public.visibility_enum AS ENUM ('public', 'private', 'unlisted');
CREATE TYPE public.app_role_enum AS ENUM ('user', 'admin', 'moderator');
CREATE TYPE public.notification_type_enum AS ENUM ('info', 'success', 'warning', 'error');
CREATE TYPE public.action_mode_enum AS ENUM ('auto', 'manual', 'disabled');

COMMENT ON TYPE public.visibility_enum IS 'Content/profile visibility levels';
COMMENT ON TYPE public.app_role_enum IS 'User application roles';
COMMENT ON TYPE public.notification_type_enum IS 'Notification severity levels';
COMMENT ON TYPE public.action_mode_enum IS 'Automation mode for syncing/processing';

-- =================================================================================
-- SECTION 2: SUBSCRIPTION INFRASTRUCTURE
-- =================================================================================

-- Subscription Tiers
CREATE TABLE public.subscription_tier (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    slug TEXT NOT NULL UNIQUE,
    display_name TEXT NOT NULL,
    description TEXT,
    
    -- Quota limits
    max_social_accounts INT NOT NULL DEFAULT 1,
    max_syncs_per_month INT NOT NULL DEFAULT 10,
    max_ai_analyses_per_month INT NOT NULL DEFAULT 25,
    max_seo_submissions_per_month INT NOT NULL DEFAULT 0,
    
    -- Pricing
    price_cents INT NOT NULL DEFAULT 0,
    currency TEXT NOT NULL DEFAULT 'usd',
    stripe_price_id TEXT,
    stripe_product_id TEXT,
    
    -- Display
    is_featured BOOLEAN DEFAULT false,
    is_active BOOLEAN DEFAULT true,
    sort_order INT DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.subscription_tier IS 'Subscription tier definitions with quotas and pricing';

CREATE INDEX idx_subscription_tier_active ON public.subscription_tier(is_active, sort_order);

-- Subscription Statuses
CREATE TABLE public.subscription_status (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    slug TEXT NOT NULL UNIQUE,
    display_name TEXT NOT NULL,
    description TEXT,
    is_active_state BOOLEAN DEFAULT true,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.subscription_status IS 'Subscription status types';

INSERT INTO public.subscription_status (slug, display_name, is_active_state) VALUES
('active', 'Active', true),
('trialing', 'Trialing', true),
('past_due', 'Past Due', true),
('canceled', 'Canceled', false),
('paused', 'Paused', false);

-- =================================================================================
-- SECTION 3: USER MANAGEMENT
-- =================================================================================

-- User Profiles
CREATE TABLE public.users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT NOT NULL,
    full_name TEXT,
    avatar_url TEXT,
    timezone TEXT DEFAULT 'UTC',
    language TEXT DEFAULT 'en',
    
    -- Onboarding
    is_onboarded BOOLEAN DEFAULT false,
    onboarded_at TIMESTAMPTZ,
    
    -- Creator public profile fields (from discovery module, but needed for base)
    display_name TEXT,
    bio TEXT,
    website_url TEXT,
    location TEXT,
    is_verified BOOLEAN DEFAULT FALSE,
    profile_slug TEXT UNIQUE,
    primary_category TEXT,
    total_followers_count BIGINT DEFAULT 0,
    profile_views_count BIGINT DEFAULT 0,
    profile_clicks_count BIGINT DEFAULT 0,
    is_public BOOLEAN DEFAULT TRUE,
    
    -- SEO
    seo_title TEXT,
    seo_description TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.users IS 'User profiles linked to Supabase Auth';

CREATE INDEX idx_users_email ON public.users(email);
CREATE INDEX idx_users_slug ON public.users(profile_slug) WHERE profile_slug IS NOT NULL;
CREATE INDEX idx_users_public ON public.users(is_public, created_at DESC) WHERE is_public = TRUE;

-- User Roles (junction table)
CREATE TABLE public.user_role (
    user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    role public.app_role_enum NOT NULL DEFAULT 'user',
    granted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    granted_by UUID REFERENCES public.users(id),
    
    PRIMARY KEY (user_id, role)
);

COMMENT ON TABLE public.user_role IS 'User role assignments (many-to-many)';

-- User Settings
CREATE TABLE public.user_setting (
    user_id UUID PRIMARY KEY REFERENCES public.users(id) ON DELETE CASCADE,
    
    -- Notification preferences
    is_email_notifications_enabled BOOLEAN DEFAULT true,
    is_push_notifications_enabled BOOLEAN DEFAULT true,
    is_weekly_digest_enabled BOOLEAN DEFAULT true,
    
    -- Auto-sync preferences
    is_auto_sync_enabled BOOLEAN DEFAULT false,
    sync_frequency_hours INT DEFAULT 24,
    
    -- AI preferences
    is_auto_ai_analysis_enabled BOOLEAN DEFAULT false,
    is_auto_apply_ai_suggestions_enabled BOOLEAN DEFAULT false,
    
    -- SEO preferences
    is_auto_seo_submission_enabled BOOLEAN DEFAULT false,
    
    -- Privacy
    is_profile_public BOOLEAN DEFAULT true,
    is_analytics_enabled BOOLEAN DEFAULT true,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.user_setting IS 'User preferences and settings';

-- =================================================================================
-- SECTION 4: SUBSCRIPTIONS
-- =================================================================================

CREATE TABLE public.subscription (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL UNIQUE REFERENCES public.users(id) ON DELETE CASCADE,
    tier_id UUID NOT NULL REFERENCES public.subscription_tier(id),
    status_id UUID NOT NULL REFERENCES public.subscription_status(id),
    
    -- Current usage (resets each billing cycle)
    syncs_used INT NOT NULL DEFAULT 0,
    ai_analyses_used INT NOT NULL DEFAULT 0,
    seo_submissions_used INT NOT NULL DEFAULT 0,
    
    -- Billing cycle
    cycle_start_date TIMESTAMPTZ NOT NULL,
    cycle_end_date TIMESTAMPTZ NOT NULL,
    next_billing_date TIMESTAMPTZ,
    
    -- Stripe integration
    stripe_customer_id TEXT,
    stripe_subscription_id TEXT,
    stripe_price_id TEXT,
    stripe_subscription_item_id_syncs TEXT,
    stripe_subscription_item_id_ai TEXT,
    stripe_subscription_item_id_seo TEXT,
    
    -- Status
    is_auto_renew_enabled BOOLEAN DEFAULT true,
    canceled_at TIMESTAMPTZ,
    cancellation_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.subscription IS 'User subscription with tier, usage tracking, and billing';

CREATE INDEX idx_subscription_user ON public.subscription(user_id);
CREATE INDEX idx_subscription_tier ON public.subscription(tier_id);
CREATE INDEX idx_subscription_status ON public.subscription(status_id);
CREATE INDEX idx_subscription_stripe_customer ON public.subscription(stripe_customer_id) WHERE stripe_customer_id IS NOT NULL;
CREATE INDEX idx_subscription_billing_cycle ON public.subscription(cycle_end_date) WHERE is_auto_renew_enabled = true;

-- =================================================================================
-- SECTION 5: NOTIFICATIONS
-- =================================================================================

CREATE TABLE public.notification (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    
    type public.notification_type_enum NOT NULL DEFAULT 'info',
    title TEXT NOT NULL,
    message TEXT NOT NULL,
    
    -- Action
    action_url TEXT,
    action_label TEXT,
    
    -- Metadata
    metadata JSONB,
    related_entity_type TEXT,
    related_entity_id UUID,
    
    -- Read status
    is_read BOOLEAN NOT NULL DEFAULT false,
    read_at TIMESTAMPTZ,
    
    -- Expiry
    expires_at TIMESTAMPTZ,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.notification IS 'User notifications';

CREATE INDEX idx_notification_user_unread ON public.notification(user_id, created_at DESC) WHERE is_read = false AND (expires_at IS NULL OR expires_at > NOW());
CREATE INDEX idx_notification_user_all ON public.notification(user_id, created_at DESC);
CREATE INDEX idx_notification_expires ON public.notification(expires_at) WHERE expires_at IS NOT NULL;

-- =================================================================================
-- SECTION 6: AUDIT & TRACKING
-- =================================================================================

CREATE TABLE public.audit_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES public.users(id) ON DELETE SET NULL,
    
    action TEXT NOT NULL,
    entity_type TEXT NOT NULL,
    entity_id UUID,
    
    old_values JSONB,
    new_values JSONB,
    
    ip_address INET,
    user_agent TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.audit_log IS 'Comprehensive audit trail of all actions';

CREATE INDEX idx_audit_log_user ON public.audit_log(user_id, created_at DESC);
CREATE INDEX idx_audit_log_entity ON public.audit_log(entity_type, entity_id, created_at DESC);
CREATE INDEX idx_audit_log_action ON public.audit_log(action, created_at DESC);
CREATE INDEX idx_audit_log_created ON public.audit_log(created_at DESC);

-- Quota Usage History
CREATE TABLE public.quota_usage_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    
    quota_type TEXT NOT NULL,
    operation TEXT NOT NULL,
    amount INT NOT NULL DEFAULT 1,
    
    -- Snapshot after operation
    current_value INT NOT NULL,
    max_value INT NOT NULL,
    
    -- Metadata
    related_entity_type TEXT,
    related_entity_id UUID,
    reason TEXT,
    
    -- Billing cycle
    billing_cycle_start TIMESTAMPTZ NOT NULL,
    billing_cycle_end TIMESTAMPTZ NOT NULL,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.quota_usage_history IS 'Historical quota usage for analytics and auditing';

CREATE INDEX idx_quota_usage_history_user ON public.quota_usage_history(user_id, created_at DESC);
CREATE INDEX idx_quota_usage_history_type ON public.quota_usage_history(user_id, quota_type, billing_cycle_start, billing_cycle_end);

-- =================================================================================
-- SECTION 7: CACHING
-- =================================================================================

CREATE TABLE public.cache_store (
    key TEXT PRIMARY KEY,
    value JSONB NOT NULL,
    category TEXT NOT NULL,
    
    expires_at TIMESTAMPTZ,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.cache_store IS 'General-purpose cache for external API data';

CREATE INDEX idx_cache_store_category ON public.cache_store(category, expires_at) WHERE expires_at IS NULL OR expires_at > NOW();
CREATE INDEX idx_cache_store_expires ON public.cache_store(expires_at) WHERE expires_at IS NOT NULL;

-- =================================================================================
-- SECTION 8: QUOTA MANAGEMENT FUNCTIONS
-- =================================================================================

-- Check quota availability
CREATE OR REPLACE FUNCTION public.check_quota(
    p_user_id UUID,
    p_quota_type TEXT
) RETURNS BOOLEAN AS $$
DECLARE
    v_current_usage INT;
    v_max_quota INT;
BEGIN
    SELECT 
        CASE p_quota_type
            WHEN 'sync' THEN s.syncs_used
            WHEN 'ai_analysis' THEN s.ai_analyses_used
            WHEN 'seo_submission' THEN s.seo_submissions_used
        END,
        CASE p_quota_type
            WHEN 'sync' THEN t.max_syncs_per_month
            WHEN 'ai_analysis' THEN t.max_ai_analyses_per_month
            WHEN 'seo_submission' THEN t.max_seo_submissions_per_month
        END
    INTO v_current_usage, v_max_quota
    FROM public.subscription s
    JOIN public.subscription_tier t ON s.tier_id = t.id
    WHERE s.user_id = p_user_id;
    
    RETURN v_current_usage < v_max_quota;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Increment quota usage
CREATE OR REPLACE FUNCTION public.increment_quota(
    p_user_id UUID,
    p_quota_type TEXT,
    p_amount INT DEFAULT 1,
    p_related_entity_type TEXT DEFAULT NULL,
    p_related_entity_id UUID DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
    v_new_usage INT;
    v_max_quota INT;
    v_cycle_start TIMESTAMPTZ;
    v_cycle_end TIMESTAMPTZ;
BEGIN
    UPDATE public.subscription s
    SET 
        syncs_used = CASE WHEN p_quota_type = 'sync' THEN syncs_used + p_amount ELSE syncs_used END,
        ai_analyses_used = CASE WHEN p_quota_type = 'ai_analysis' THEN ai_analyses_used + p_amount ELSE ai_analyses_used END,
        seo_submissions_used = CASE WHEN p_quota_type = 'seo_submission' THEN seo_submissions_used + p_amount ELSE seo_submissions_used END,
        updated_at = NOW()
    WHERE user_id = p_user_id
    RETURNING 
        CASE p_quota_type
            WHEN 'sync' THEN syncs_used
            WHEN 'ai_analysis' THEN ai_analyses_used
            WHEN 'seo_submission' THEN seo_submissions_used
        END,
        cycle_start_date,
        cycle_end_date
    INTO v_new_usage, v_cycle_start, v_cycle_end;
    
    SELECT 
        CASE p_quota_type
            WHEN 'sync' THEN t.max_syncs_per_month
            WHEN 'ai_analysis' THEN t.max_ai_analyses_per_month
            WHEN 'seo_submission' THEN t.max_seo_submissions_per_month
        END
    INTO v_max_quota
    FROM public.subscription s
    JOIN public.subscription_tier t ON s.tier_id = t.id
    WHERE s.user_id = p_user_id;
    
    INSERT INTO public.quota_usage_history (
        user_id, quota_type, operation, amount, current_value, max_value,
        related_entity_type, related_entity_id, billing_cycle_start, billing_cycle_end
    ) VALUES (
        p_user_id, p_quota_type, 'increment', p_amount, v_new_usage, v_max_quota,
        p_related_entity_type, p_related_entity_id, v_cycle_start, v_cycle_end
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Decrement quota usage (rollback/refund)
CREATE OR REPLACE FUNCTION public.decrement_quota(
    p_user_id UUID,
    p_quota_type TEXT,
    p_amount INT DEFAULT 1,
    p_reason TEXT DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
    v_new_usage INT;
    v_max_quota INT;
    v_cycle_start TIMESTAMPTZ;
    v_cycle_end TIMESTAMPTZ;
BEGIN
    UPDATE public.subscription s
    SET 
        syncs_used = CASE WHEN p_quota_type = 'sync' THEN GREATEST(0, syncs_used - p_amount) ELSE syncs_used END,
        ai_analyses_used = CASE WHEN p_quota_type = 'ai_analysis' THEN GREATEST(0, ai_analyses_used - p_amount) ELSE ai_analyses_used END,
        seo_submissions_used = CASE WHEN p_quota_type = 'seo_submission' THEN GREATEST(0, seo_submissions_used - p_amount) ELSE seo_submissions_used END,
        updated_at = NOW()
    WHERE user_id = p_user_id
    RETURNING 
        CASE p_quota_type
            WHEN 'sync' THEN syncs_used
            WHEN 'ai_analysis' THEN ai_analyses_used
            WHEN 'seo_submission' THEN seo_submissions_used
        END,
        cycle_start_date,
        cycle_end_date
    INTO v_new_usage, v_cycle_start, v_cycle_end;
    
    SELECT 
        CASE p_quota_type
            WHEN 'sync' THEN t.max_syncs_per_month
            WHEN 'ai_analysis' THEN t.max_ai_analyses_per_month
            WHEN 'seo_submission' THEN t.max_seo_submissions_per_month
        END
    INTO v_max_quota
    FROM public.subscription s
    JOIN public.subscription_tier t ON s.tier_id = t.id
    WHERE s.user_id = p_user_id;
    
    INSERT INTO public.quota_usage_history (
        user_id, quota_type, operation, amount, current_value, max_value,
        reason, billing_cycle_start, billing_cycle_end
    ) VALUES (
        p_user_id, p_quota_type, 'decrement', p_amount, v_new_usage, v_max_quota,
        p_reason, v_cycle_start, v_cycle_end
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Check if user has role
CREATE OR REPLACE FUNCTION public.has_role(
    p_user_id UUID,
    p_role public.app_role_enum
) RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM public.user_role
        WHERE user_id = p_user_id AND role = p_role
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =================================================================================
-- SECTION 9: TRIGGERS
-- =================================================================================

-- Auto-update updated_at
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_users_updated_at BEFORE UPDATE ON public.users FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER trg_user_setting_updated_at BEFORE UPDATE ON public.user_setting FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER trg_subscription_updated_at BEFORE UPDATE ON public.subscription FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER trg_notification_updated_at BEFORE UPDATE ON public.notification FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- =================================================================================
-- SECTION 10: ROW LEVEL SECURITY
-- =================================================================================

ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_role ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_setting ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscription ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notification ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.audit_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.quota_usage_history ENABLE ROW LEVEL SECURITY;

-- Users can read/update their own profile
CREATE POLICY users_select_own ON public.users FOR SELECT USING (auth.uid() = id);
CREATE POLICY users_update_own ON public.users FOR UPDATE USING (auth.uid() = id);

-- Public profiles are viewable
CREATE POLICY users_select_public ON public.users FOR SELECT USING (is_public = true);

-- User settings
CREATE POLICY user_setting_all_own ON public.user_setting FOR ALL USING (auth.uid() = user_id);

-- Subscriptions
CREATE POLICY subscription_select_own ON public.subscription FOR SELECT USING (auth.uid() = user_id);

-- Notifications
CREATE POLICY notification_select_own ON public.notification FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY notification_update_own ON public.notification FOR UPDATE USING (auth.uid() = user_id);

-- Audit log
CREATE POLICY audit_log_select_own ON public.audit_log FOR SELECT USING (auth.uid() = user_id);

-- Quota history
CREATE POLICY quota_usage_history_select_own ON public.quota_usage_history FOR SELECT USING (auth.uid() = user_id);

-- Admin policies
CREATE POLICY users_admin_all ON public.users FOR ALL USING (public.has_role(auth.uid(), 'admin'));
CREATE POLICY subscription_admin_all ON public.subscription FOR ALL USING (public.has_role(auth.uid(), 'admin'));
CREATE POLICY audit_log_admin_all ON public.audit_log FOR ALL USING (public.has_role(auth.uid(), 'admin'));

-- =================================================================================
-- SECTION 11: INITIAL DATA
-- =================================================================================

-- Subscription tiers
INSERT INTO public.subscription_tier (slug, display_name, description, max_social_accounts, max_syncs_per_month, max_ai_analyses_per_month, max_seo_submissions_per_month, price_cents, currency, is_featured, sort_order)
VALUES
('free', 'Free', 'Perfect for getting started', 1, 10, 25, 0, 0, 'usd', false, 1),
('basic', 'Basic', 'For content creators', 3, 100, 100, 50, 1900, 'usd', true, 2),
('premium', 'Premium', 'For professionals and teams', 10, 500, 500, 200, 4900, 'usd', true, 3);

-- =================================================================================
-- SECTION 12: GRANTS & PERMISSIONS
-- =================================================================================

GRANT USAGE ON SCHEMA public TO authenticated, anon;
GRANT SELECT ON public.subscription_tier TO authenticated, anon;
GRANT SELECT ON public.subscription_status TO authenticated, anon;
GRANT ALL ON public.users TO authenticated;
GRANT ALL ON public.user_role TO authenticated;
GRANT ALL ON public.user_setting TO authenticated;
GRANT ALL ON public.subscription TO authenticated;
GRANT ALL ON public.notification TO authenticated;
GRANT ALL ON public.audit_log TO authenticated;
GRANT ALL ON public.quota_usage_history TO authenticated;
GRANT ALL ON public.cache_store TO authenticated;
GRANT EXECUTE ON FUNCTION public.check_quota TO authenticated;
GRANT EXECUTE ON FUNCTION public.increment_quota TO authenticated;
GRANT EXECUTE ON FUNCTION public.decrement_quota TO authenticated;
GRANT EXECUTE ON FUNCTION public.has_role TO authenticated;

-- =================================================================================
-- MODULE VERIFICATION
-- =================================================================================

DO $$
BEGIN
    RAISE NOTICE 'âœ… Module 000: Base Core Schema - COMPLETE';
    RAISE NOTICE '   Tables: 10 (users, user_role, user_setting, subscription, subscription_tier, subscription_status, notification, audit_log, quota_usage_history, cache_store)';
    RAISE NOTICE '   Functions: 4 (check_quota, increment_quota, decrement_quota, has_role)';
    RAISE NOTICE '   Enums: 4 (visibility_enum, app_role_enum, notification_type_enum, action_mode_enum)';
    RAISE NOTICE '   RLS Policies: 12';
    RAISE NOTICE '';
    RAISE NOTICE 'ðŸ§ª Test this module:';
    RAISE NOTICE '   1. Create test user via Supabase Auth';
    RAISE NOTICE '   2. Verify user row auto-created in users table';
    RAISE NOTICE '   3. Assign free tier subscription';
    RAISE NOTICE '   4. Test quota functions: SELECT check_quota(user_id, ''sync'')';
    RAISE NOTICE '   5. Test role assignment and has_role() function';
    RAISE NOTICE '';
    RAISE NOTICE 'âž¡ï¸  Next: Apply 001_platform_connections.sql';
END $$;
-- =================================================================================
-- MODULE 001: PLATFORM CONNECTIONS & SOCIAL ACCOUNTS
-- =================================================================================
-- Purpose: OAuth connections to social media platforms (YouTube, Instagram, TikTok)
-- Dependencies: 000_base_core.sql (requires users table)
-- Testing: OAuth flow, token storage in Vault, account linking
-- Date: November 8, 2025
-- 
-- Tables Created:
--   - Lookup: platform, account_status
--   - Core: platform_connection, social_account
-- 
-- Key Features:
--   - Vault-based credential storage (NOT in database!)
--   - OAuth token expiry tracking
--   - Multi-account support per platform
--   - Auto-sync scheduling
-- =================================================================================

-- =================================================================================
-- SECTION 1: LOOKUP TABLES
-- =================================================================================

-- Platforms
CREATE TABLE public.platform (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    slug TEXT NOT NULL UNIQUE,
    display_name TEXT NOT NULL,
    description TEXT,
    website_url TEXT,
    logo_url TEXT,
    api_docs_url TEXT,
    is_oauth_required BOOLEAN NOT NULL DEFAULT true,
    is_active BOOLEAN NOT NULL DEFAULT true,
    sort_order INT DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.platform IS 'Supported social media platforms';

-- Account Statuses
CREATE TABLE public.account_status (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    slug TEXT NOT NULL UNIQUE,
    display_name TEXT NOT NULL,
    description TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.account_status IS 'Social account connection statuses';

INSERT INTO public.account_status (slug, display_name) VALUES
('active', 'Active'),
('inactive', 'Inactive'),
('suspended', 'Suspended'),
('disconnected', 'Disconnected');

-- =================================================================================
-- SECTION 2: PLATFORM CONNECTIONS (OAuth Credentials)
-- =================================================================================

CREATE TABLE public.platform_connection (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    platform_id UUID NOT NULL REFERENCES public.platform(id),
    
    -- Vault secret reference (NOT actual credentials!)
    vault_secret_name TEXT NOT NULL,
    
    -- OAuth details
    scopes TEXT[],
    token_expires_at TIMESTAMPTZ,
    
    -- Platform account info
    platform_user_id TEXT NOT NULL,
    platform_username TEXT,
    platform_display_name TEXT,
    platform_avatar_url TEXT,
    
    -- Status
    is_active BOOLEAN NOT NULL DEFAULT true,
    is_verified BOOLEAN DEFAULT false,
    last_verified_at TIMESTAMPTZ,
    last_error TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, platform_id)
);

COMMENT ON TABLE public.platform_connection IS 'User platform OAuth connections with Vault-stored credentials';
COMMENT ON COLUMN public.platform_connection.vault_secret_name IS 'Supabase Vault secret key (e.g., user_123_youtube_token)';

CREATE INDEX idx_platform_connection_user_platform ON public.platform_connection(user_id, platform_id) WHERE is_active = true;
CREATE INDEX idx_platform_connection_expiring ON public.platform_connection(token_expires_at) WHERE is_active = true AND token_expires_at < NOW() + INTERVAL '7 days';

-- =================================================================================
-- SECTION 3: SOCIAL ACCOUNTS (User's channels/profiles)
-- =================================================================================

CREATE TABLE public.social_account (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    connection_id UUID NOT NULL REFERENCES public.platform_connection(id) ON DELETE CASCADE,
    platform_id UUID NOT NULL REFERENCES public.platform(id),
    status_id UUID NOT NULL REFERENCES public.account_status(id),
    
    -- Account details
    account_name TEXT NOT NULL,
    account_url TEXT,
    description TEXT,
    follower_count INT DEFAULT 0,
    following_count INT DEFAULT 0,
    post_count INT DEFAULT 0,
    
    -- Sync settings
    sync_mode public.action_mode_enum DEFAULT 'manual',
    last_synced_at TIMESTAMPTZ,
    last_sync_status TEXT,
    next_sync_at TIMESTAMPTZ,
    
    -- Visibility
    visibility public.visibility_enum DEFAULT 'public',
    is_primary BOOLEAN DEFAULT false,
    
    -- Soft delete
    deleted_at TIMESTAMPTZ,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.social_account IS 'Connected social media accounts/channels';

CREATE INDEX idx_social_account_user ON public.social_account(user_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_social_account_connection ON public.social_account(connection_id);
CREATE INDEX idx_social_account_platform ON public.social_account(platform_id);
CREATE INDEX idx_social_account_user_platform_active ON public.social_account(user_id, platform_id, is_primary) WHERE deleted_at IS NULL;
CREATE INDEX idx_social_account_next_sync ON public.social_account(next_sync_at) WHERE sync_mode = 'auto' AND deleted_at IS NULL;

-- =================================================================================
-- SECTION 4: TRIGGERS
-- =================================================================================

CREATE TRIGGER trg_platform_connection_updated_at BEFORE UPDATE ON public.platform_connection FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER trg_social_account_updated_at BEFORE UPDATE ON public.social_account FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- =================================================================================
-- SECTION 5: ROW LEVEL SECURITY
-- =================================================================================

ALTER TABLE public.platform_connection ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.social_account ENABLE ROW LEVEL SECURITY;

-- Users can manage their own connections
CREATE POLICY platform_connection_all_own ON public.platform_connection FOR ALL USING (auth.uid() = user_id);

-- Users can manage their own social accounts
CREATE POLICY social_account_all_own ON public.social_account FOR ALL USING (auth.uid() = user_id);

-- =================================================================================
-- SECTION 6: INITIAL DATA
-- =================================================================================

INSERT INTO public.platform (slug, display_name, description, is_oauth_required, sort_order)
VALUES
('youtube', 'YouTube', 'Video sharing platform', true, 1),
('instagram', 'Instagram', 'Photo and video sharing', true, 2),
('tiktok', 'TikTok', 'Short-form video platform', true, 3),
('facebook', 'Facebook', 'Social networking platform', true, 4),
('twitter', 'Twitter/X', 'Microblogging platform', true, 5);

-- =================================================================================
-- SECTION 7: GRANTS & PERMISSIONS
-- =================================================================================

GRANT SELECT ON public.platform TO authenticated, anon;
GRANT SELECT ON public.account_status TO authenticated, anon;
GRANT ALL ON public.platform_connection TO authenticated;
GRANT ALL ON public.social_account TO authenticated;

-- =================================================================================
-- MODULE VERIFICATION
-- =================================================================================

DO $$
BEGIN
    RAISE NOTICE 'âœ… Module 001: Platform Connections - COMPLETE';
    RAISE NOTICE '   Tables: 4 (platform, account_status, platform_connection, social_account)';
    RAISE NOTICE '   Platforms: 5 (YouTube, Instagram, TikTok, Facebook, Twitter)';
    RAISE NOTICE '   RLS Policies: 2';
    RAISE NOTICE '';
    RAISE NOTICE 'ðŸ§ª Test this module:';
    RAISE NOTICE '   1. Deploy oauth-youtube-init Edge Function';
    RAISE NOTICE '   2. Test OAuth flow: GET /functions/v1/oauth-youtube-init';
    RAISE NOTICE '   3. Verify platform_connection created with vault_secret_name';
    RAISE NOTICE '   4. Check credentials stored in Supabase Vault (NOT in database!)';
    RAISE NOTICE '   5. Verify social_account auto-created with channel info';
    RAISE NOTICE '';
    RAISE NOTICE 'âš ï¸  Critical: Credentials NEVER stored in database - only Vault references!';
    RAISE NOTICE 'âž¡ï¸  Next: Apply 002_content_management.sql';
END $$;
-- =================================================================================
-- MODULE 002: CONTENT MANAGEMENT
-- =================================================================================
-- Purpose: Store and manage synced content from social platforms
-- Dependencies: 
--   - 000_base_core.sql (requires users table)
--   - 001_platform_connections.sql (requires social_account, platform, content_type tables)
-- Testing: Sync content, track edits, search functionality
-- Date: November 8, 2025
-- 
-- Tables Created:
--   - Lookup: content_type
--   - Core: content_item, content_revision
-- 
-- Key Features:
--   - Full-text search with tsvector
--   - Soft delete support
--   - Edit history tracking
--   - Multi-platform content aggregation
-- =================================================================================

-- =================================================================================
-- SECTION 1: LOOKUP TABLES
-- =================================================================================

CREATE TABLE public.content_type (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    slug TEXT NOT NULL UNIQUE,
    display_name TEXT NOT NULL,
    description TEXT,
    is_active BOOLEAN NOT NULL DEFAULT true,
    sort_order INT DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.content_type IS 'Types of content (videos, images, posts, etc)';

-- =================================================================================
-- SECTION 2: CONTENT ITEMS
-- =================================================================================

CREATE TABLE public.content_item (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    social_account_id UUID NOT NULL REFERENCES public.social_account(id) ON DELETE RESTRICT,
    platform_id UUID NOT NULL REFERENCES public.platform(id),
    content_type_id UUID NOT NULL REFERENCES public.content_type(id),
    
    -- Platform content reference
    platform_content_id TEXT NOT NULL,
    platform_url TEXT,
    
    -- Content metadata
    title TEXT,
    description TEXT,
    thumbnail_url TEXT,
    media_url TEXT,
    duration_seconds INT,
    
    -- Engagement metrics
    views_count INT DEFAULT 0,
    likes_count INT DEFAULT 0,
    comments_count INT DEFAULT 0,
    shares_count INT DEFAULT 0,
    
    -- SEO & discovery
    tags TEXT[],
    hashtags TEXT[],
    category TEXT,
    language TEXT DEFAULT 'en',
    
    -- AI enhancements (will be populated by AI module)
    ai_description TEXT,
    
    -- Full-text search
    search_vector tsvector GENERATED ALWAYS AS (
        setweight(to_tsvector('english', coalesce(title, '')), 'A') ||
        setweight(to_tsvector('english', coalesce(description, '')), 'B') ||
        setweight(to_tsvector('english', array_to_string(coalesce(tags, ARRAY[]::TEXT[]), ' ')), 'C')
    ) STORED,
    
    -- Timestamps
    published_at TIMESTAMPTZ NOT NULL,
    synced_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Visibility
    visibility public.visibility_enum DEFAULT 'public',
    
    -- SEO overrides (from discovery module)
    seo_title TEXT,
    seo_description TEXT,
    canonical_url TEXT,
    
    -- Click tracking (from discovery module)
    total_clicks INT DEFAULT 0,
    clicks_last_7_days INT DEFAULT 0,
    clicks_last_30_days INT DEFAULT 0,
    
    -- Podcast/eBook fields (platform-specific)
    episode_number INT,
    season_number INT,
    podcast_show_name TEXT,
    podcast_show_id TEXT,
    isbn TEXT,
    book_author TEXT,
    book_publisher TEXT,
    publication_date DATE,
    page_count INT,
    amazon_rating DECIMAL(3,2),
    amazon_reviews_count INT,
    
    -- Embed caching
    embed_html TEXT,
    embed_cached_at TIMESTAMPTZ,
    
    -- Soft delete
    deleted_at TIMESTAMPTZ,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(platform_id, platform_content_id)
);

COMMENT ON TABLE public.content_item IS 'Synced content from social media platforms';

-- Composite indexes for common queries
CREATE INDEX idx_content_item_account ON public.content_item(social_account_id, published_at DESC) WHERE deleted_at IS NULL;
CREATE INDEX idx_content_item_platform ON public.content_item(platform_id, published_at DESC) WHERE deleted_at IS NULL;
CREATE INDEX idx_content_item_published ON public.content_item(published_at DESC) WHERE deleted_at IS NULL AND visibility = 'public';
CREATE INDEX idx_content_item_search ON public.content_item USING GIN(search_vector);
CREATE INDEX idx_content_item_tags ON public.content_item USING GIN(tags) WHERE tags IS NOT NULL;
CREATE INDEX idx_content_item_hashtags ON public.content_item USING GIN(hashtags) WHERE hashtags IS NOT NULL;

-- =================================================================================
-- SECTION 3: CONTENT REVISIONS (Edit History)
-- =================================================================================

CREATE TABLE public.content_revision (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    content_item_id UUID NOT NULL REFERENCES public.content_item(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE SET NULL,
    
    -- Changed fields
    field_name TEXT NOT NULL,
    old_value TEXT,
    new_value TEXT,
    
    -- Metadata
    change_source TEXT,
    change_reason TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.content_revision IS 'Audit trail of content modifications';

CREATE INDEX idx_content_revision_content ON public.content_revision(content_item_id, created_at DESC);
CREATE INDEX idx_content_revision_user ON public.content_revision(user_id, created_at DESC);

-- =================================================================================
-- SECTION 4: HELPER FUNCTIONS
-- =================================================================================

-- Prevent deletion of social accounts with content
CREATE OR REPLACE FUNCTION public.prevent_account_deletion_with_content()
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM public.content_item
        WHERE social_account_id = OLD.id
        AND deleted_at IS NULL
    ) THEN
        RAISE EXCEPTION 'Cannot delete social account with existing content. Archive content first.';
    END IF;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_prevent_account_deletion_with_content
    BEFORE DELETE ON public.social_account
    FOR EACH ROW EXECUTE FUNCTION public.prevent_account_deletion_with_content();

-- =================================================================================
-- SECTION 5: TRIGGERS
-- =================================================================================

CREATE TRIGGER trg_content_item_updated_at BEFORE UPDATE ON public.content_item FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- =================================================================================
-- SECTION 6: ROW LEVEL SECURITY
-- =================================================================================

ALTER TABLE public.content_item ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.content_revision ENABLE ROW LEVEL SECURITY;

-- Users can manage their own content
CREATE POLICY content_item_all_own ON public.content_item
FOR ALL USING (
    auth.uid() IN (
        SELECT user_id FROM public.social_account
        WHERE id = content_item.social_account_id
    )
);

-- Public content viewable by anyone
CREATE POLICY content_item_select_public ON public.content_item
FOR SELECT USING (
    visibility = 'public' AND deleted_at IS NULL
);

-- Content revisions viewable by owner
CREATE POLICY content_revision_select_own ON public.content_revision
FOR SELECT USING (auth.uid() = user_id);

-- =================================================================================
-- SECTION 7: INITIAL DATA
-- =================================================================================

INSERT INTO public.content_type (slug, display_name, description, sort_order)
VALUES
('long_video', 'Long Video', 'Videos longer than 60 seconds', 1),
('short_video', 'Short Video', 'Videos 60 seconds or less', 2),
('image', 'Image', 'Static images and photos', 3),
('carousel', 'Carousel', 'Multiple images in sequence', 4),
('story', 'Story', 'Temporary content (24 hours)', 5),
('reel', 'Reel', 'Short vertical video', 6),
('post', 'Post', 'Text-based post', 7);

-- =================================================================================
-- SECTION 8: GRANTS & PERMISSIONS
-- =================================================================================

GRANT SELECT ON public.content_type TO authenticated, anon;
GRANT ALL ON public.content_item TO authenticated;
GRANT ALL ON public.content_revision TO authenticated;

-- =================================================================================
-- MODULE VERIFICATION
-- =================================================================================

DO $$
BEGIN
    RAISE NOTICE 'âœ… Module 002: Content Management - COMPLETE';
    RAISE NOTICE '   Tables: 3 (content_type, content_item, content_revision)';
    RAISE NOTICE '   Content Types: 7 (long_video, short_video, image, carousel, story, reel, post)';
    RAISE NOTICE '   Indexes: 8 (including GIN for full-text search)';
    RAISE NOTICE '   RLS Policies: 3';
    RAISE NOTICE '';
    RAISE NOTICE 'ðŸ§ª Test this module:';
    RAISE NOTICE '   1. Deploy sync-youtube Edge Function';
    RAISE NOTICE '   2. Sync content: POST /functions/v1/sync-youtube with social_account_id';
    RAISE NOTICE '   3. Verify content_item rows created with platform metadata';
    RAISE NOTICE '   4. Test search: SELECT * FROM content_item WHERE search_vector @@ plainto_tsquery(''gaming'')';
    RAISE NOTICE '   5. Test soft delete protection on social_account';
    RAISE NOTICE '';
    RAISE NOTICE 'ðŸ” Search Features:';
    RAISE NOTICE '   - Full-text search on title, description, tags';
    RAISE NOTICE '   - GIN indexes for array columns (tags, hashtags)';
    RAISE NOTICE '   - Generated tsvector column (auto-updated)';
    RAISE NOTICE '';
    RAISE NOTICE 'âž¡ï¸  Next: Apply 003_ai_integration.sql';
END $$;
-- =================================================================================
-- MODULE 003: AI INTEGRATION
-- =================================================================================
-- Purpose: AI-powered content analysis, tag generation, and optimization suggestions
-- Dependencies:
--   - 000_base_core.sql (requires users table)
--   - 002_content_management.sql (requires content_item table)
-- Testing: AI tag generation, trend analysis, cost tracking
-- Date: November 8, 2025
-- 
-- Tables Created:
--   - Lookup: ai_provider, search_engine
--   - Core: ai_model, user_ai_setting, ai_suggestion, ai_suggestion_application, ai_usage, trending_keyword
-- 
-- Key Features:
--   - Multi-provider support (OpenAI, Anthropic, Google, Local)
--   - Token usage and cost tracking
--   - Suggestion versioning
--   - Trending keyword caching
-- =================================================================================

-- =================================================================================
-- SECTION 1: AI PROVIDERS & MODELS
-- =================================================================================

CREATE TABLE public.ai_provider (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    slug TEXT NOT NULL UNIQUE,
    display_name TEXT NOT NULL,
    base_url TEXT,
    is_api_key_required BOOLEAN DEFAULT true,
    is_streaming_supported BOOLEAN DEFAULT false,
    is_active BOOLEAN DEFAULT true,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.ai_provider IS 'Supported AI providers';

CREATE TABLE public.ai_model (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    provider_id UUID NOT NULL REFERENCES public.ai_provider(id),
    model_name TEXT NOT NULL,
    display_name TEXT NOT NULL,
    capabilities TEXT[],
    max_context_tokens INT DEFAULT 8192,
    input_cost_per_1k_tokens DECIMAL(10,4),
    output_cost_per_1k_tokens DECIMAL(10,4),
    is_active BOOLEAN DEFAULT true,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(provider_id, model_name)
);

COMMENT ON TABLE public.ai_model IS 'AI models with pricing information';

-- =================================================================================
-- SECTION 2: USER AI SETTINGS
-- =================================================================================

CREATE TABLE public.user_ai_setting (
    user_id UUID PRIMARY KEY REFERENCES public.users(id) ON DELETE CASCADE,
    preferred_provider_id UUID REFERENCES public.ai_provider(id),
    preferred_model_id UUID REFERENCES public.ai_model(id),
    tone TEXT DEFAULT 'professional',
    language TEXT DEFAULT 'en',
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.user_ai_setting IS 'User AI preferences';

-- =================================================================================
-- SECTION 3: AI SUGGESTIONS
-- =================================================================================

CREATE TABLE public.ai_suggestion (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    content_item_id UUID NOT NULL REFERENCES public.content_item(id) ON DELETE CASCADE,
    provider_id UUID REFERENCES public.ai_provider(id),
    model_id UUID REFERENCES public.ai_model(id),
    
    -- Suggestions
    suggested_titles TEXT[],
    suggested_description TEXT,
    suggested_tags TEXT[],
    suggested_category TEXT,
    trending_keywords TEXT[],
    trending_hashtags TEXT[],
    related_topics TEXT[],
    
    -- Scores (0.00 to 1.00)
    trending_score DECIMAL(3,2),
    seo_score DECIMAL(3,2),
    readability_score DECIMAL(3,2),
    confidence_score DECIMAL(3,2),
    
    -- Analysis
    sentiment TEXT,
    target_audience TEXT[],
    
    -- API usage
    prompt_tokens INT,
    completion_tokens INT,
    total_cost_cents DECIMAL(10,2),
    processing_time_ms INT,
    
    -- Application status
    is_applied BOOLEAN DEFAULT false,
    applied_at TIMESTAMPTZ,
    
    -- Versioning
    version INT DEFAULT 1,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.ai_suggestion IS 'AI-generated content optimization suggestions';

CREATE INDEX idx_ai_suggestion_content ON public.ai_suggestion(content_item_id, created_at DESC);
CREATE INDEX idx_ai_suggestion_pending ON public.ai_suggestion(content_item_id, is_applied, created_at DESC) WHERE is_applied = false;
CREATE INDEX idx_ai_suggestion_trending ON public.ai_suggestion(trending_score DESC, created_at DESC) WHERE trending_score IS NOT NULL;
CREATE INDEX idx_ai_suggestion_keywords ON public.ai_suggestion USING GIN(trending_keywords) WHERE trending_keywords IS NOT NULL;

-- AI Suggestion Applications
CREATE TABLE public.ai_suggestion_application (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    suggestion_id UUID NOT NULL REFERENCES public.ai_suggestion(id) ON DELETE CASCADE,
    field_name TEXT NOT NULL,
    applied_value TEXT,
    applied_by_user_id UUID NOT NULL REFERENCES public.users(id),
    
    applied_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.ai_suggestion_application IS 'Track which AI suggestion fields were applied';

CREATE INDEX idx_ai_suggestion_application_suggestion ON public.ai_suggestion_application(suggestion_id);

-- =================================================================================
-- SECTION 4: AI USAGE TRACKING
-- =================================================================================

CREATE TABLE public.ai_usage (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    provider_id UUID NOT NULL REFERENCES public.ai_provider(id),
    model_id UUID NOT NULL REFERENCES public.ai_model(id),
    content_item_id UUID REFERENCES public.content_item(id) ON DELETE SET NULL,
    
    operation_type TEXT NOT NULL,
    prompt_tokens INT NOT NULL,
    completion_tokens INT NOT NULL,
    total_tokens INT NOT NULL,
    cost_cents DECIMAL(10,2) NOT NULL,
    processing_time_ms INT,
    
    -- Billing period
    billing_cycle_start TIMESTAMPTZ NOT NULL,
    billing_cycle_end TIMESTAMPTZ NOT NULL,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.ai_usage IS 'AI API usage tracking for billing';

CREATE INDEX idx_ai_usage_user_billing ON public.ai_usage(user_id, billing_cycle_start, billing_cycle_end);
CREATE INDEX idx_ai_usage_provider_model ON public.ai_usage(provider_id, model_id, created_at DESC);

-- =================================================================================
-- SECTION 5: TRENDING KEYWORDS CACHE
-- =================================================================================

CREATE TABLE public.trending_keyword (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    platform_id UUID NOT NULL REFERENCES public.platform(id),
    keyword TEXT NOT NULL,
    category TEXT,
    trending_score DECIMAL(5,2) NOT NULL,
    search_volume INT,
    competition_level TEXT,
    source TEXT,
    region TEXT DEFAULT 'US',
    language TEXT DEFAULT 'en',
    valid_from TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    valid_until TIMESTAMPTZ NOT NULL,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(platform_id, keyword, region, language, valid_from)
);

COMMENT ON TABLE public.trending_keyword IS 'Cached trending keywords from various sources';

CREATE INDEX idx_trending_keyword_platform ON public.trending_keyword(platform_id, trending_score DESC) WHERE valid_until > NOW();
CREATE INDEX idx_trending_keyword_valid ON public.trending_keyword(valid_until) WHERE valid_until > NOW();

-- =================================================================================
-- SECTION 6: TRIGGERS
-- =================================================================================

CREATE TRIGGER trg_ai_suggestion_updated_at BEFORE UPDATE ON public.ai_suggestion FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- =================================================================================
-- SECTION 7: ROW LEVEL SECURITY
-- =================================================================================

ALTER TABLE public.user_ai_setting ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ai_suggestion ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ai_suggestion_application ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ai_usage ENABLE ROW LEVEL SECURITY;

-- Users can manage their AI settings
CREATE POLICY user_ai_setting_all_own ON public.user_ai_setting FOR ALL USING (auth.uid() = user_id);

-- Users can view suggestions for their content
CREATE POLICY ai_suggestion_all_own ON public.ai_suggestion
FOR ALL USING (
    auth.uid() IN (
        SELECT sa.user_id
        FROM public.content_item ci
        JOIN public.social_account sa ON ci.social_account_id = sa.id
        WHERE ci.id = ai_suggestion.content_item_id
    )
);

-- Users can view their AI usage
CREATE POLICY ai_usage_select_own ON public.ai_usage FOR SELECT USING (auth.uid() = user_id);

-- =================================================================================
-- SECTION 8: INITIAL DATA
-- =================================================================================

INSERT INTO public.ai_provider (slug, display_name, base_url, is_api_key_required, is_streaming_supported)
VALUES
('openai', 'OpenAI', 'https://api.openai.com/v1', true, true),
('anthropic', 'Anthropic', 'https://api.anthropic.com/v1', true, true),
('google', 'Google AI', 'https://generativelanguage.googleapis.com/v1', true, false),
('local', 'Local Model', 'http://localhost:11434', false, true);

INSERT INTO public.ai_model (provider_id, model_name, display_name, capabilities, max_context_tokens, input_cost_per_1k_tokens, output_cost_per_1k_tokens)
SELECT 
    p.id,
    m.model_name,
    m.display_name,
    m.capabilities,
    m.max_context_tokens,
    m.input_cost,
    m.output_cost
FROM public.ai_provider p
CROSS JOIN (VALUES
    ('openai', 'gpt-4o', 'GPT-4o', ARRAY['text_generation', 'vision'], 128000, 2.50, 10.00),
    ('openai', 'gpt-4o-mini', 'GPT-4o Mini', ARRAY['text_generation', 'vision'], 128000, 0.15, 0.60),
    ('anthropic', 'claude-3-5-sonnet-20241022', 'Claude 3.5 Sonnet', ARRAY['text_generation', 'vision'], 200000, 3.00, 15.00),
    ('google', 'gemini-1.5-pro', 'Gemini 1.5 Pro', ARRAY['text_generation', 'vision'], 2000000, 1.25, 5.00),
    ('local', 'llama3.2', 'Llama 3.2', ARRAY['text_generation'], 8192, 0.00, 0.00)
) AS m(provider_slug, model_name, display_name, capabilities, max_context_tokens, input_cost, output_cost)
WHERE p.slug = m.provider_slug;

-- =================================================================================
-- SECTION 9: GRANTS & PERMISSIONS
-- =================================================================================

GRANT SELECT ON public.ai_provider TO authenticated, anon;
GRANT SELECT ON public.ai_model TO authenticated, anon;
GRANT ALL ON public.user_ai_setting TO authenticated;
GRANT ALL ON public.ai_suggestion TO authenticated;
GRANT ALL ON public.ai_suggestion_application TO authenticated;
GRANT ALL ON public.ai_usage TO authenticated;
GRANT ALL ON public.trending_keyword TO authenticated;

-- =================================================================================
-- MODULE VERIFICATION
-- =================================================================================

DO $$
BEGIN
    RAISE NOTICE 'âœ… Module 003: AI Integration - COMPLETE';
    RAISE NOTICE '   Tables: 7 (ai_provider, ai_model, user_ai_setting, ai_suggestion, ai_suggestion_application, ai_usage, trending_keyword)';
    RAISE NOTICE '   AI Providers: 4 (OpenAI, Anthropic, Google AI, Local)';
    RAISE NOTICE '   AI Models: 5 (GPT-4o, GPT-4o Mini, Claude 3.5, Gemini 1.5 Pro, Llama 3.2)';
    RAISE NOTICE '   RLS Policies: 4';
    RAISE NOTICE '';
    RAISE NOTICE 'ðŸ§ª Test this module:';
    RAISE NOTICE '   1. Deploy ai-generate-tags Edge Function';
    RAISE NOTICE '   2. Set OPENAI_API_KEY in Supabase secrets';
    RAISE NOTICE '   3. Generate tags: POST /functions/v1/ai-generate-tags with content_item_id';
    RAISE NOTICE '   4. Verify ai_suggestion created with suggested_titles, suggested_tags, trending_keywords';
    RAISE NOTICE '   5. Check ai_usage table for cost tracking';
    RAISE NOTICE '   6. Test quota: Ensure ai_analyses_used incremented in subscription table';
    RAISE NOTICE '';
    RAISE NOTICE 'ðŸ’° Cost Tracking:';
    RAISE NOTICE '   - Token usage logged per request';
    RAISE NOTICE '   - Cost calculated from model pricing';
    RAISE NOTICE '   - Billing cycle tracking';
    RAISE NOTICE '';
    RAISE NOTICE 'âž¡ï¸  Next: Apply 004_seo_integration.sql';
END $$;
-- =================================================================================
-- MODULE 004: SEO INTEGRATION
-- =================================================================================
-- Purpose: Search engine indexing integration (Google, Bing, Yandex, IndexNow)
-- Dependencies:
--   - 000_base_core.sql (requires users table)
--   - 002_content_management.sql (requires content_item table)
-- Testing: SEO submission, indexing status tracking
-- Date: November 8, 2025
-- 
-- Tables Created:
--   - Lookup: search_engine
--   - Core: seo_connection, seo_submission, seo_usage
-- 
-- Key Features:
--   - Multi-search engine support
--   - Vault-based API credential storage
--   - Submission status tracking
--   - Auto-retry failed submissions
-- =================================================================================

-- =================================================================================
-- SECTION 1: SEARCH ENGINES
-- =================================================================================

CREATE TABLE public.search_engine (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    slug TEXT NOT NULL UNIQUE,
    display_name TEXT NOT NULL,
    api_endpoint TEXT,
    api_docs_url TEXT,
    supports_indexnow BOOLEAN DEFAULT false,
    is_active BOOLEAN DEFAULT true,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.search_engine IS 'Supported search engines for SEO indexing';

INSERT INTO public.search_engine (slug, display_name, api_endpoint, supports_indexnow) VALUES
('google', 'Google Search Console', 'https://indexing.googleapis.com/v3', false),
('bing', 'Bing Webmaster Tools', 'https://ssl.bing.com/webmaster/api.svc/json', true),
('yandex', 'Yandex Webmaster', 'https://api.webmaster.yandex.net/v4', false),
('indexnow', 'IndexNow Protocol', 'https://api.indexnow.org', true);

-- =================================================================================
-- SECTION 2: SEO CONNECTIONS
-- =================================================================================

CREATE TABLE public.seo_connection (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    search_engine_id UUID NOT NULL REFERENCES public.search_engine(id),
    
    -- Credentials stored in Vault
    vault_secret_name TEXT NOT NULL,
    site_url TEXT NOT NULL,
    
    -- Status
    is_active BOOLEAN DEFAULT true,
    is_verified BOOLEAN DEFAULT false,
    last_verified_at TIMESTAMPTZ,
    last_error TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(user_id, search_engine_id, site_url)
);

COMMENT ON TABLE public.seo_connection IS 'User search engine connections with Vault-stored credentials';

CREATE INDEX idx_seo_connection_user_engine ON public.seo_connection(user_id, search_engine_id) WHERE is_active = true;

-- =================================================================================
-- SECTION 3: SEO SUBMISSIONS
-- =================================================================================

CREATE TABLE public.seo_submission (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    content_item_id UUID NOT NULL REFERENCES public.content_item(id) ON DELETE CASCADE,
    connection_id UUID NOT NULL REFERENCES public.seo_connection(id),
    search_engine_id UUID NOT NULL REFERENCES public.search_engine(id),
    
    -- Submission details
    submitted_url TEXT NOT NULL,
    submission_type TEXT NOT NULL,
    submission_method TEXT,
    
    -- Request/Response
    request_payload JSONB,
    response_status INT,
    response_body JSONB,
    
    -- Indexing status
    status TEXT NOT NULL DEFAULT 'pending',
    status_checked_at TIMESTAMPTZ,
    index_status_url TEXT,
    coverage_state TEXT,
    
    -- Error handling
    error_message TEXT,
    retry_count INT DEFAULT 0,
    next_retry_at TIMESTAMPTZ,
    
    submitted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    indexed_at TIMESTAMPTZ,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.seo_submission IS 'SEO URL submissions to search engines';

CREATE INDEX idx_seo_submission_content ON public.seo_submission(content_item_id, created_at DESC);
CREATE INDEX idx_seo_submission_connection ON public.seo_submission(connection_id, submitted_at DESC);
CREATE INDEX idx_seo_submission_status ON public.seo_submission(status, next_retry_at) WHERE status IN ('pending', 'failed');
CREATE INDEX idx_seo_submission_engine ON public.seo_submission(search_engine_id, submitted_at DESC);

-- =================================================================================
-- SECTION 4: SEO USAGE TRACKING
-- =================================================================================

CREATE TABLE public.seo_usage (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    search_engine_id UUID NOT NULL REFERENCES public.search_engine(id),
    content_item_id UUID REFERENCES public.content_item(id) ON DELETE SET NULL,
    
    operation_type TEXT NOT NULL,
    urls_count INT DEFAULT 1,
    
    -- Billing period
    billing_cycle_start TIMESTAMPTZ NOT NULL,
    billing_cycle_end TIMESTAMPTZ NOT NULL,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.seo_usage IS 'SEO API usage tracking for billing';

CREATE INDEX idx_seo_usage_user_billing ON public.seo_usage(user_id, billing_cycle_start, billing_cycle_end);
CREATE INDEX idx_seo_usage_engine ON public.seo_usage(search_engine_id, created_at DESC);

-- =================================================================================
-- SECTION 5: TRIGGERS
-- =================================================================================

CREATE TRIGGER trg_seo_submission_updated_at BEFORE UPDATE ON public.seo_submission FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- =================================================================================
-- SECTION 6: ROW LEVEL SECURITY
-- =================================================================================

ALTER TABLE public.seo_connection ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.seo_submission ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.seo_usage ENABLE ROW LEVEL SECURITY;

-- Users can manage their SEO connections
CREATE POLICY seo_connection_all_own ON public.seo_connection FOR ALL USING (auth.uid() = user_id);

-- Users can manage their SEO submissions
CREATE POLICY seo_submission_all_own ON public.seo_submission
FOR ALL USING (
    auth.uid() IN (
        SELECT user_id FROM public.seo_connection
        WHERE id = seo_submission.connection_id
    )
);

-- Users can view their SEO usage
CREATE POLICY seo_usage_select_own ON public.seo_usage FOR SELECT USING (auth.uid() = user_id);

-- =================================================================================
-- SECTION 7: GRANTS & PERMISSIONS
-- =================================================================================

GRANT SELECT ON public.search_engine TO authenticated, anon;
GRANT ALL ON public.seo_connection TO authenticated;
GRANT ALL ON public.seo_submission TO authenticated;
GRANT ALL ON public.seo_usage TO authenticated;

-- =================================================================================
-- MODULE VERIFICATION
-- =================================================================================

DO $$
BEGIN
    RAISE NOTICE 'âœ… Module 004: SEO Integration - COMPLETE';
    RAISE NOTICE '   Tables: 4 (search_engine, seo_connection, seo_submission, seo_usage)';
    RAISE NOTICE '   Search Engines: 4 (Google, Bing, Yandex, IndexNow)';
    RAISE NOTICE '   RLS Policies: 3';
    RAISE NOTICE '';
    RAISE NOTICE 'ðŸ§ª Test this module:';
    RAISE NOTICE '   1. Set up Google Search Console API credentials';
    RAISE NOTICE '   2. Store credentials in Vault via Supabase dashboard';
    RAISE NOTICE '   3. Create seo_connection with vault_secret_name';
    RAISE NOTICE '   4. Submit URL: Use Google Indexing API to submit content_item URL';
    RAISE NOTICE '   5. Check seo_submission table for status';
    RAISE NOTICE '   6. Verify seo_submissions_used incremented in subscription table';
    RAISE NOTICE '';
    RAISE NOTICE 'ðŸ” Security:';
    RAISE NOTICE '   - API keys stored in Vault (NOT database)';
    RAISE NOTICE '   - RLS policies enforce user ownership';
    RAISE NOTICE '   - Retry logic for failed submissions';
    RAISE NOTICE '';
    RAISE NOTICE 'âž¡ï¸  Next: Apply 005_discovery_platform.sql';
END $$;
-- =================================================================================
-- MODULE 005: DISCOVERY PLATFORM
-- =================================================================================
-- Purpose: Public discovery features - categories, tags, trending, creator profiles
-- Dependencies:
--   - 000_base_core.sql (requires users table)
--   - 002_content_management.sql (requires content_item table)
-- Testing: Browse content, search creators, trending algorithms
-- Date: November 8, 2025
-- 
-- Tables Created:
--   - Lookup: content_category
--   - Core: content_tag, content_click, content_media, trending_content, featured_creator
-- 
-- Key Features:
--   - Category-based content discovery
--   - AI and platform-generated tags
--   - Click tracking and analytics
--   - Multi-media support (carousels)
--   - Trending algorithm
--   - Featured creators curation
-- =================================================================================

-- =================================================================================
-- SECTION 1: CONTENT CATEGORIES
-- =================================================================================

CREATE TABLE public.content_category (
    code TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    parent_category TEXT REFERENCES public.content_category(code),
    icon_name TEXT,
    sort_order INT DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

COMMENT ON TABLE public.content_category IS 'Content categorization for discovery';

INSERT INTO public.content_category (code, name, description, sort_order) VALUES
('music', 'Music', 'Songs, music videos, covers, live performances', 1),
('gaming', 'Gaming', 'Gameplay, reviews, walkthroughs, esports', 2),
('education', 'Education', 'Tutorials, courses, how-tos, lectures', 3),
('lifestyle', 'Lifestyle', 'Vlogs, daily life, travel, personal stories', 4),
('comedy', 'Comedy', 'Sketches, standup, funny videos, memes', 5),
('tech', 'Technology', 'Reviews, news, coding tutorials, gadgets', 6),
('beauty', 'Beauty & Fashion', 'Makeup, skincare, fashion, styling', 7),
('fitness', 'Fitness & Health', 'Workouts, nutrition, wellness, sports', 8),
('food', 'Food & Cooking', 'Recipes, cooking shows, food reviews', 9),
('business', 'Business & Finance', 'Entrepreneurship, investing, marketing', 10),
('art', 'Arts & Crafts', 'Drawing, painting, DIY, creative projects', 11),
('entertainment', 'Entertainment', 'Movies, TV shows, celebrity news', 12),
('news', 'News & Politics', 'Current events, commentary, journalism', 13),
('science', 'Science', 'Research, experiments, documentaries', 14),
('other', 'Other', 'Miscellaneous content', 99)
ON CONFLICT (code) DO NOTHING;

-- Add category reference to content_item (if not exists)
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'content_item' AND column_name = 'category_code'
    ) THEN
        ALTER TABLE public.content_item 
        ADD COLUMN category_code TEXT REFERENCES public.content_category(code);
        
        CREATE INDEX idx_content_category ON public.content_item(category_code) WHERE category_code IS NOT NULL;
    END IF;
END $$;

-- =================================================================================
-- SECTION 2: CONTENT TAGS
-- =================================================================================

CREATE TABLE public.content_tag (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    content_id UUID NOT NULL REFERENCES public.content_item(id) ON DELETE CASCADE,
    tag TEXT NOT NULL,
    source TEXT NOT NULL CHECK (source IN ('ai_generated', 'platform_original', 'user_added')),
    confidence_score DECIMAL(3,2),
    tag_type TEXT CHECK (tag_type IN ('keyword', 'topic', 'entity', 'emotion', 'trend', 'hashtag')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES public.users(id)
);

COMMENT ON TABLE public.content_tag IS 'AI-generated and platform tags for content discoverability';

CREATE INDEX idx_content_tag_content ON public.content_tag(content_id);
CREATE INDEX idx_content_tag_search ON public.content_tag(tag) WHERE source = 'ai_generated';
CREATE INDEX idx_content_tag_type ON public.content_tag(tag_type, tag);
CREATE UNIQUE INDEX idx_content_tag_unique ON public.content_tag(content_id, tag, source);

-- =================================================================================
-- SECTION 3: CLICK TRACKING
-- =================================================================================

CREATE TABLE public.content_click (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    content_id UUID NOT NULL REFERENCES public.content_item(id) ON DELETE CASCADE,
    user_id UUID REFERENCES public.users(id),
    clicked_at TIMESTAMPTZ DEFAULT NOW(),
    referrer TEXT,
    user_agent TEXT,
    ip_address INET,
    country_code TEXT,
    city TEXT
);

COMMENT ON TABLE public.content_click IS 'Track clicks from StreamVibe to original platform';

CREATE INDEX idx_content_click_content ON public.content_click(content_id, clicked_at DESC);
CREATE INDEX idx_content_click_date ON public.content_click(clicked_at DESC);
CREATE INDEX idx_content_click_user ON public.content_click(user_id, clicked_at DESC) WHERE user_id IS NOT NULL;

-- Function to increment click counters
CREATE OR REPLACE FUNCTION public.increment_content_clicks(p_content_id UUID)
RETURNS VOID AS $$
BEGIN
    UPDATE public.content_item
    SET 
        total_clicks = total_clicks + 1,
        clicks_last_7_days = (
            SELECT COUNT(*) FROM public.content_click 
            WHERE content_id = p_content_id 
            AND clicked_at > NOW() - INTERVAL '7 days'
        ),
        clicks_last_30_days = (
            SELECT COUNT(*) FROM public.content_click 
            WHERE content_id = p_content_id 
            AND clicked_at > NOW() - INTERVAL '30 days'
        )
    WHERE id = p_content_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =================================================================================
-- SECTION 4: MULTI-MEDIA SUPPORT
-- =================================================================================

CREATE TABLE public.content_media (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    content_id UUID NOT NULL REFERENCES public.content_item(id) ON DELETE CASCADE,
    media_url TEXT NOT NULL,
    media_type TEXT NOT NULL CHECK (media_type IN ('image', 'video', 'audio')),
    display_order INT NOT NULL DEFAULT 1,
    width INT,
    height INT,
    duration_seconds INT,
    thumbnail_url TEXT,
    file_size_bytes BIGINT,
    mime_type TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

COMMENT ON TABLE public.content_media IS 'Multiple media items per content (Instagram carousels, albums)';

CREATE INDEX idx_content_media_content ON public.content_media(content_id, display_order);
CREATE INDEX idx_content_media_type ON public.content_media(media_type);

-- =================================================================================
-- SECTION 5: TRENDING CONTENT
-- =================================================================================

CREATE TABLE public.trending_content (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    content_id UUID NOT NULL REFERENCES public.content_item(id) ON DELETE CASCADE,
    trend_score DECIMAL(10,2) NOT NULL,
    trend_category TEXT NOT NULL CHECK (trend_category IN ('today', 'week', 'month', 'all_time')),
    rank_position INT,
    started_trending_at TIMESTAMPTZ DEFAULT NOW(),
    last_updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(content_id, trend_category)
);

COMMENT ON TABLE public.trending_content IS 'Algorithm-based trending content for homepage discovery';

CREATE INDEX idx_trending_category ON public.trending_content(trend_category, rank_position);
CREATE INDEX idx_trending_score ON public.trending_content(trend_score DESC);

-- Function to calculate trending score
CREATE OR REPLACE FUNCTION public.calculate_trend_score(
    p_clicks INT,
    p_views INT,
    p_created_at TIMESTAMPTZ
)
RETURNS DECIMAL AS $$
DECLARE
    v_click_score DECIMAL;
    v_view_score DECIMAL;
    v_recency_score DECIMAL;
    v_days_old INT;
BEGIN
    v_click_score := LEAST(p_clicks / 1000.0, 1.0) * 0.4;
    v_view_score := LEAST(p_views / 100000.0, 1.0) * 0.3;
    v_days_old := EXTRACT(EPOCH FROM (NOW() - p_created_at)) / 86400;
    v_recency_score := GREATEST(1.0 - (v_days_old / 30.0), 0) * 0.3;
    
    RETURN v_click_score + v_view_score + v_recency_score;
END;
$$ LANGUAGE plpgsql;

-- =================================================================================
-- SECTION 6: FEATURED CREATORS
-- =================================================================================

CREATE TABLE public.featured_creator (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    featured_reason TEXT,
    featured_until TIMESTAMPTZ,
    display_order INT DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES public.users(id)
);

COMMENT ON TABLE public.featured_creator IS 'Manually curated featured creators';

CREATE INDEX idx_featured_active ON public.featured_creator(featured_until, display_order) WHERE featured_until > NOW();

-- =================================================================================
-- SECTION 7: HELPER FUNCTIONS
-- =================================================================================

-- Generate unique profile slug
CREATE OR REPLACE FUNCTION public.generate_profile_slug(p_display_name TEXT, p_user_id UUID)
RETURNS TEXT AS $$
DECLARE
    v_slug TEXT;
    v_counter INT := 0;
    v_temp_slug TEXT;
BEGIN
    v_slug := lower(regexp_replace(p_display_name, '[^a-zA-Z0-9\s-]', '', 'g'));
    v_slug := regexp_replace(v_slug, '\s+', '-', 'g');
    v_slug := regexp_replace(v_slug, '-+', '-', 'g');
    v_slug := trim(both '-' from v_slug);
    v_slug := substring(v_slug from 1 for 50);
    
    v_temp_slug := v_slug;
    
    WHILE EXISTS (SELECT 1 FROM public.users WHERE profile_slug = v_temp_slug AND id != p_user_id) LOOP
        v_counter := v_counter + 1;
        v_temp_slug := v_slug || '-' || v_counter;
    END LOOP;
    
    RETURN v_temp_slug;
END;
$$ LANGUAGE plpgsql;

-- Update total followers from connected platforms
CREATE OR REPLACE FUNCTION public.update_total_followers(p_user_id UUID)
RETURNS VOID AS $$
BEGIN
    UPDATE public.users
    SET total_followers_count = (
        SELECT COALESCE(SUM(follower_count), 0)
        FROM public.social_account
        WHERE user_id = p_user_id
    )
    WHERE id = p_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =================================================================================
-- SECTION 8: ROW LEVEL SECURITY
-- =================================================================================

ALTER TABLE public.content_tag ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.content_click ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.content_media ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.trending_content ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.featured_creator ENABLE ROW LEVEL SECURITY;

-- Public read access
CREATE POLICY content_tag_select_public ON public.content_tag FOR SELECT USING (true);
CREATE POLICY content_media_select_public ON public.content_media FOR SELECT USING (true);
CREATE POLICY trending_content_select_public ON public.trending_content FOR SELECT USING (true);
CREATE POLICY featured_creator_select_public ON public.featured_creator FOR SELECT USING (true);

-- Users can add tags to their content
CREATE POLICY content_tag_insert_own ON public.content_tag 
FOR INSERT 
WITH CHECK (
    EXISTS (
        SELECT 1 FROM public.content_item 
        JOIN public.social_account ON content_item.social_account_id = social_account.id
        WHERE content_item.id = content_tag.content_id 
        AND social_account.user_id = auth.uid()
    )
);

-- Anyone can track clicks
CREATE POLICY content_click_insert_public ON public.content_click FOR INSERT WITH CHECK (true);

-- Only admins manage trending/featured
CREATE POLICY trending_content_admin_all ON public.trending_content FOR ALL USING (public.has_role(auth.uid(), 'admin'));
CREATE POLICY featured_creator_admin_all ON public.featured_creator FOR ALL USING (public.has_role(auth.uid(), 'admin'));

-- =================================================================================
-- SECTION 9: GRANTS & PERMISSIONS
-- =================================================================================

GRANT SELECT ON public.content_category TO authenticated, anon;
GRANT SELECT, INSERT ON public.content_tag TO authenticated;
GRANT SELECT ON public.content_media TO authenticated, anon;
GRANT INSERT ON public.content_click TO authenticated, anon;
GRANT SELECT ON public.trending_content TO authenticated, anon;
GRANT SELECT ON public.featured_creator TO authenticated, anon;
GRANT EXECUTE ON FUNCTION public.generate_profile_slug TO authenticated;
GRANT EXECUTE ON FUNCTION public.update_total_followers TO authenticated;
GRANT EXECUTE ON FUNCTION public.increment_content_clicks TO authenticated, anon;
GRANT EXECUTE ON FUNCTION public.calculate_trend_score TO authenticated;

-- =================================================================================
-- MODULE VERIFICATION
-- =================================================================================

DO $$
BEGIN
    RAISE NOTICE 'âœ… Module 005: Discovery Platform - COMPLETE';
    RAISE NOTICE '   Tables: 6 (content_category, content_tag, content_click, content_media, trending_content, featured_creator)';
    RAISE NOTICE '   Categories: 15 (music, gaming, education, etc.)';
    RAISE NOTICE '   Functions: 4 (generate_profile_slug, update_total_followers, increment_content_clicks, calculate_trend_score)';
    RAISE NOTICE '   RLS Policies: 7';
    RAISE NOTICE '';
    RAISE NOTICE 'ðŸ§ª Test this module:';
    RAISE NOTICE '   1. Deploy browse-content Edge Function';
    RAISE NOTICE '   2. Browse by category: GET /functions/v1/browse-content?category=gaming';
    RAISE NOTICE '   3. Search creators: GET /functions/v1/search-creators?q=tech';
    RAISE NOTICE '   4. Track click: POST /functions/v1/track-click with content_id';
    RAISE NOTICE '   5. View trending: GET /functions/v1/get-trending?period=today';
    RAISE NOTICE '   6. Verify click counters updated in content_item';
    RAISE NOTICE '';
    RAISE NOTICE 'ðŸ”¥ Trending Algorithm:';
    RAISE NOTICE '   - Score = (clicks * 0.4) + (views * 0.3) + (recency * 0.3)';
    RAISE NOTICE '   - Updated daily via pg_cron';
    RAISE NOTICE '   - Categories: today, week, month, all_time';
    RAISE NOTICE '';
    RAISE NOTICE 'âž¡ï¸  Next: Apply 006_async_infrastructure.sql (FINAL MODULE)';
END $$;
-- =================================================================================
-- MODULE 006: ASYNC INFRASTRUCTURE
-- =================================================================================
-- Purpose: Background job queue, Stripe webhooks, and caching infrastructure
-- Dependencies: 
--   - 000_base_core.sql (requires users, subscription, cache_store tables)
-- Testing: Job creation, webhook processing, cache operations
-- Date: November 8, 2025
--
-- Tables Created:
--   - Lookup: job_type
--   - Core: job_queue, job_log, stripe_webhook_events
-- 
-- Key Features:
--   - Async job queue with status tracking
--   - Job deduplication (5-min window)
--   - Result caching (1-hour TTL)
--   - Stripe webhook idempotency
--   - Auto-retry with exponential backoff
--   - Comprehensive monitoring
-- =================================================================================

-- =================================================================================
-- SECTION 1: JOB TYPES LOOKUP
-- =================================================================================

CREATE TABLE public.job_type (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    slug TEXT NOT NULL UNIQUE,
    display_name TEXT NOT NULL,
    description TEXT,
    is_active BOOLEAN NOT NULL DEFAULT true,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.job_type IS 'Types of background jobs';

INSERT INTO public.job_type (slug, display_name, description)
VALUES
('platform_sync', 'Platform Sync', 'Sync content from social media platform'),
('ai_analysis', 'AI Analysis', 'Analyze content with AI'),
('seo_submission', 'SEO Submission', 'Submit URL to search engines'),
('quota_reset', 'Quota Reset', 'Reset monthly quotas'),
('token_refresh', 'Token Refresh', 'Refresh OAuth tokens');

-- =================================================================================
-- SECTION 2: JOB QUEUE
-- =================================================================================

CREATE TABLE public.job_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    
    -- Job identification
    job_type TEXT NOT NULL CHECK (job_type IN (
        'sync_youtube', 'sync_instagram', 'sync_tiktok',
        'ai_generate_tags', 'ai_bulk_tag',
        'auto_sync', 'follower_sync'
    )),
    job_priority INT DEFAULT 5 CHECK (job_priority BETWEEN 1 AND 10),
    
    -- Job parameters
    params JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    -- Status tracking
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
        'pending', 'processing', 'completed', 'failed', 'cancelled'
    )),
    progress_percent INT DEFAULT 0 CHECK (progress_percent BETWEEN 0 AND 100),
    progress_message TEXT,
    
    -- Execution metadata
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    worker_id TEXT,
    
    -- Error handling
    error_message TEXT,
    error_code TEXT,
    error_details JSONB,
    retry_count INT DEFAULT 0,
    max_retries INT DEFAULT 3,
    
    -- Result storage
    result JSONB,
    
    -- Scheduling
    scheduled_for TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ DEFAULT NOW() + INTERVAL '24 hours',
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    CONSTRAINT valid_completion CHECK (
        (status IN ('completed', 'failed', 'cancelled') AND completed_at IS NOT NULL)
        OR (status IN ('pending', 'processing'))
    )
);

COMMENT ON TABLE public.job_queue IS 'Background job queue for async operations';

-- Job Queue Indexes (11 optimized indexes)
CREATE INDEX idx_job_queue_user_status_created ON public.job_queue(user_id, status, created_at DESC);
CREATE INDEX idx_job_queue_pending_pickup ON public.job_queue(status, scheduled_for, job_priority DESC, id) WHERE status = 'pending';
CREATE INDEX idx_job_queue_worker_active ON public.job_queue(worker_id, status, started_at DESC) WHERE status = 'processing';
CREATE INDEX idx_job_queue_cleanup ON public.job_queue(status, completed_at) WHERE status IN ('completed', 'cancelled', 'failed');
CREATE INDEX idx_job_queue_retry_eligible ON public.job_queue(status, retry_count, updated_at) WHERE status = 'failed';
CREATE INDEX idx_job_queue_type_status ON public.job_queue(job_type, status) WHERE status IN ('pending', 'processing', 'failed');
CREATE INDEX idx_job_queue_user_active ON public.job_queue(user_id, status) WHERE status IN ('pending', 'processing');
CREATE INDEX idx_job_queue_expiration ON public.job_queue(status, expires_at) WHERE status = 'pending';
CREATE INDEX idx_job_queue_stuck_detection ON public.job_queue(status, started_at) WHERE status = 'processing';
CREATE INDEX idx_job_queue_params_gin ON public.job_queue USING gin(params jsonb_path_ops);
CREATE INDEX idx_job_queue_result_gin ON public.job_queue USING gin(result jsonb_path_ops) WHERE result IS NOT NULL;

-- =================================================================================
-- SECTION 3: JOB LOGS
-- =================================================================================

CREATE TABLE public.job_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    job_id UUID NOT NULL REFERENCES public.job_queue(id) ON DELETE CASCADE,
    
    log_level TEXT NOT NULL CHECK (log_level IN ('debug', 'info', 'warning', 'error')),
    message TEXT NOT NULL,
    metadata JSONB,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.job_log IS 'Detailed execution logs for background jobs';

CREATE INDEX idx_job_log_job_time ON public.job_log(job_id, created_at DESC);
CREATE INDEX idx_job_log_errors ON public.job_log(log_level, created_at DESC) WHERE log_level IN ('error', 'warning');
CREATE INDEX idx_job_log_message_fts ON public.job_log USING gin(to_tsvector('english', message));
CREATE INDEX idx_job_log_metadata_gin ON public.job_log USING gin(metadata jsonb_path_ops) WHERE metadata IS NOT NULL;

-- =================================================================================
-- SECTION 4: STRIPE WEBHOOKS
-- =================================================================================

CREATE TABLE public.stripe_webhook_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Stripe event identification
    stripe_event_id TEXT NOT NULL UNIQUE,
    event_type TEXT NOT NULL,
    
    -- Event data
    event_data JSONB NOT NULL,
    
    -- Processing status
    processed BOOLEAN NOT NULL DEFAULT false,
    processed_at TIMESTAMPTZ,
    error_message TEXT,
    retry_count INT NOT NULL DEFAULT 0,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.stripe_webhook_events IS 'Stripe webhook event log for idempotency';

CREATE INDEX idx_stripe_webhook_event_id ON public.stripe_webhook_events(stripe_event_id);
CREATE INDEX idx_stripe_webhook_type ON public.stripe_webhook_events(event_type);
CREATE INDEX idx_stripe_webhook_processed ON public.stripe_webhook_events(processed, created_at);
CREATE INDEX idx_stripe_webhook_unprocessed ON public.stripe_webhook_events(processed, retry_count) WHERE processed = false;
CREATE INDEX idx_stripe_webhook_created ON public.stripe_webhook_events(created_at DESC);

-- =================================================================================
-- SECTION 5: JOB MANAGEMENT FUNCTIONS
-- =================================================================================

-- Create job
CREATE OR REPLACE FUNCTION public.create_job(
    p_user_id UUID,
    p_job_type TEXT,
    p_params JSONB DEFAULT '{}'::jsonb,
    p_priority INT DEFAULT 5,
    p_scheduled_for TIMESTAMPTZ DEFAULT NOW()
)
RETURNS UUID AS $$
DECLARE
    v_job_id UUID;
    v_pending_count INT;
BEGIN
    SELECT COUNT(*) INTO v_pending_count
    FROM public.job_queue
    WHERE user_id = p_user_id AND status IN ('pending', 'processing');
    
    IF v_pending_count >= 10 THEN
        RAISE EXCEPTION 'Maximum 10 concurrent jobs per user';
    END IF;
    
    INSERT INTO public.job_queue (user_id, job_type, params, job_priority, status, scheduled_for)
    VALUES (p_user_id, p_job_type, p_params, p_priority, 'pending', p_scheduled_for)
    RETURNING id INTO v_job_id;
    
    RETURN v_job_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update job progress
CREATE OR REPLACE FUNCTION public.update_job_progress(
    p_job_id UUID,
    p_progress_percent INT,
    p_progress_message TEXT DEFAULT NULL
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE public.job_queue
    SET progress_percent = p_progress_percent,
        progress_message = COALESCE(p_progress_message, progress_message),
        updated_at = NOW()
    WHERE id = p_job_id AND status = 'processing';
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Start job
CREATE OR REPLACE FUNCTION public.start_job(p_job_id UUID, p_worker_id TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE public.job_queue
    SET status = 'processing', started_at = NOW(), worker_id = p_worker_id, updated_at = NOW()
    WHERE id = p_job_id AND status = 'pending';
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Complete job
CREATE OR REPLACE FUNCTION public.complete_job(p_job_id UUID, p_result JSONB DEFAULT NULL)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE public.job_queue
    SET status = 'completed', completed_at = NOW(), progress_percent = 100, 
        result = p_result, updated_at = NOW()
    WHERE id = p_job_id AND status = 'processing';
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Fail job
CREATE OR REPLACE FUNCTION public.fail_job(
    p_job_id UUID,
    p_error_message TEXT,
    p_error_code TEXT DEFAULT 'JOB_ERROR',
    p_error_details JSONB DEFAULT NULL
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE public.job_queue
    SET status = 'failed', completed_at = NOW(),
        error_message = p_error_message, error_code = p_error_code,
        error_details = p_error_details, updated_at = NOW()
    WHERE id = p_job_id AND status = 'processing';
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Cancel job
CREATE OR REPLACE FUNCTION public.cancel_job(p_job_id UUID, p_user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE public.job_queue
    SET status = 'cancelled', completed_at = NOW(), updated_at = NOW()
    WHERE id = p_job_id AND user_id = p_user_id AND status IN ('pending', 'processing');
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add job log
CREATE OR REPLACE FUNCTION public.add_job_log(
    p_job_id UUID,
    p_log_level TEXT,
    p_message TEXT,
    p_metadata JSONB DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    v_log_id UUID;
BEGIN
    INSERT INTO public.job_log (job_id, log_level, message, metadata)
    VALUES (p_job_id, p_log_level, p_message, p_metadata)
    RETURNING id INTO v_log_id;
    RETURN v_log_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get user jobs (paginated)
CREATE OR REPLACE FUNCTION public.get_user_jobs(
    p_user_id UUID,
    p_status TEXT DEFAULT NULL,
    p_job_type TEXT DEFAULT NULL,
    p_limit INT DEFAULT 50,
    p_offset INT DEFAULT 0
)
RETURNS TABLE(
    job_id UUID, job_type TEXT, status TEXT, progress_percent INT,
    progress_message TEXT, error_message TEXT, error_code TEXT,
    result JSONB, created_at TIMESTAMPTZ, started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ, total_count BIGINT
) AS $$
DECLARE
    v_total_count BIGINT;
BEGIN
    SELECT COUNT(*) INTO v_total_count
    FROM public.job_queue
    WHERE user_id = p_user_id
      AND (p_status IS NULL OR job_queue.status = p_status)
      AND (p_job_type IS NULL OR job_queue.job_type = p_job_type);
    
    RETURN QUERY
    SELECT jq.id, jq.job_type, jq.status, jq.progress_percent, jq.progress_message,
           jq.error_message, jq.error_code, jq.result, jq.created_at, jq.started_at,
           jq.completed_at, v_total_count
    FROM public.job_queue jq
    WHERE jq.user_id = p_user_id
      AND (p_status IS NULL OR jq.status = p_status)
      AND (p_job_type IS NULL OR jq.job_type = p_job_type)
    ORDER BY jq.created_at DESC
    LIMIT p_limit OFFSET p_offset;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get job logs (paginated)
CREATE OR REPLACE FUNCTION public.get_job_logs(
    p_job_id UUID,
    p_user_id UUID,
    p_log_level TEXT DEFAULT NULL,
    p_limit INT DEFAULT 100,
    p_offset INT DEFAULT 0
)
RETURNS TABLE(
    log_id UUID, log_level TEXT, message TEXT, metadata JSONB,
    created_at TIMESTAMPTZ, total_count BIGINT
) AS $$
DECLARE
    v_total_count BIGINT;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM public.job_queue WHERE id = p_job_id AND user_id = p_user_id) THEN
        RAISE EXCEPTION 'Job not found or access denied';
    END IF;
    
    SELECT COUNT(*) INTO v_total_count
    FROM public.job_log
    WHERE job_id = p_job_id AND (p_log_level IS NULL OR job_log.log_level = p_log_level);
    
    RETURN QUERY
    SELECT jl.id, jl.log_level, jl.message, jl.metadata, jl.created_at, v_total_count
    FROM public.job_log jl
    WHERE jl.job_id = p_job_id AND (p_log_level IS NULL OR jl.log_level = p_log_level)
    ORDER BY jl.created_at DESC
    LIMIT p_limit OFFSET p_offset;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Find or create job (deduplication)
CREATE OR REPLACE FUNCTION public.find_or_create_job(
    p_user_id UUID,
    p_job_type TEXT,
    p_params JSONB DEFAULT '{}'::jsonb,
    p_priority INT DEFAULT 5,
    p_dedupe_window INTERVAL DEFAULT INTERVAL '5 minutes'
)
RETURNS TABLE(job_id UUID, is_new BOOLEAN, existing_status TEXT) AS $$
DECLARE
    v_existing_job_id UUID;
    v_existing_status TEXT;
    v_new_job_id UUID;
    v_pending_count INT;
BEGIN
    SELECT jq.id, jq.status INTO v_existing_job_id, v_existing_status
    FROM public.job_queue jq
    WHERE jq.user_id = p_user_id
      AND jq.job_type = p_job_type
      AND jq.params = p_params
      AND jq.status IN ('pending', 'processing')
      AND jq.created_at > NOW() - p_dedupe_window
    ORDER BY jq.created_at DESC LIMIT 1;
    
    IF v_existing_job_id IS NOT NULL THEN
        RETURN QUERY SELECT v_existing_job_id, FALSE, v_existing_status;
        RETURN;
    END IF;
    
    SELECT COUNT(*) INTO v_pending_count
    FROM public.job_queue WHERE user_id = p_user_id AND status IN ('pending', 'processing');
    
    IF v_pending_count >= 10 THEN
        RAISE EXCEPTION 'Maximum 10 concurrent jobs per user';
    END IF;
    
    INSERT INTO public.job_queue (user_id, job_type, params, job_priority, status, scheduled_for)
    VALUES (p_user_id, p_job_type, p_params, p_priority, 'pending', NOW())
    RETURNING id INTO v_new_job_id;
    
    RETURN QUERY SELECT v_new_job_id, TRUE, 'pending'::TEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get cached job result
CREATE OR REPLACE FUNCTION public.get_cached_job_result(
    p_user_id UUID,
    p_job_type TEXT,
    p_params JSONB,
    p_cache_ttl INTERVAL DEFAULT INTERVAL '1 hour'
)
RETURNS TABLE(job_id UUID, result JSONB, completed_at TIMESTAMPTZ, age INTERVAL) AS $$
BEGIN
    RETURN QUERY
    SELECT jq.id, jq.result, jq.completed_at, NOW() - jq.completed_at AS age
    FROM public.job_queue jq
    WHERE jq.user_id = p_user_id
      AND jq.job_type = p_job_type
      AND jq.params = p_params
      AND jq.status = 'completed'
      AND jq.result IS NOT NULL
      AND jq.completed_at > NOW() - p_cache_ttl
    ORDER BY jq.completed_at DESC LIMIT 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get job queue stats
CREATE OR REPLACE FUNCTION public.get_job_queue_stats(p_user_id UUID DEFAULT NULL)
RETURNS TABLE(
    total_jobs BIGINT, pending_jobs BIGINT, processing_jobs BIGINT,
    completed_jobs BIGINT, failed_jobs BIGINT, avg_processing_time INTERVAL,
    total_errors BIGINT, jobs_by_type JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) AS total_jobs,
        COUNT(*) FILTER (WHERE status = 'pending') AS pending_jobs,
        COUNT(*) FILTER (WHERE status = 'processing') AS processing_jobs,
        COUNT(*) FILTER (WHERE status = 'completed') AS completed_jobs,
        COUNT(*) FILTER (WHERE status = 'failed') AS failed_jobs,
        AVG(completed_at - started_at) FILTER (WHERE completed_at IS NOT NULL) AS avg_processing_time,
        COUNT(*) FILTER (WHERE error_message IS NOT NULL) AS total_errors,
        jsonb_object_agg(job_type, jsonb_build_object(
            'total', COUNT(*),
            'pending', COUNT(*) FILTER (WHERE status = 'pending'),
            'completed', COUNT(*) FILTER (WHERE status = 'completed'),
            'failed', COUNT(*) FILTER (WHERE status = 'failed')
        )) AS jobs_by_type
    FROM public.job_queue
    WHERE p_user_id IS NULL OR user_id = p_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Retry failed jobs
CREATE OR REPLACE FUNCTION public.retry_failed_jobs()
RETURNS TABLE(retried_job_id UUID, job_type TEXT) AS $$
BEGIN
    RETURN QUERY
    UPDATE public.job_queue
    SET status = 'pending',
        retry_count = retry_count + 1,
        scheduled_for = NOW() + (retry_count * INTERVAL '5 minutes'),
        error_message = NULL, error_code = NULL, error_details = NULL,
        updated_at = NOW()
    WHERE status = 'failed'
      AND retry_count < max_retries
      AND updated_at < NOW() - INTERVAL '5 minutes'
      AND expires_at > NOW()
    RETURNING id, job_queue.job_type;
END;
$$ LANGUAGE plpgsql;

-- Cleanup old jobs
CREATE OR REPLACE FUNCTION public.cleanup_old_jobs()
RETURNS TABLE(deleted_count BIGINT) AS $$
DECLARE
    v_deleted_count BIGINT;
BEGIN
    DELETE FROM public.job_queue
    WHERE status IN ('completed', 'cancelled')
      AND completed_at < NOW() - INTERVAL '7 days';
    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
    RETURN QUERY SELECT v_deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Expire stale jobs
CREATE OR REPLACE FUNCTION public.expire_stale_jobs()
RETURNS TABLE(expired_job_id UUID) AS $$
BEGIN
    RETURN QUERY
    UPDATE public.job_queue
    SET status = 'failed', completed_at = NOW(),
        error_message = 'Job expired before processing',
        error_code = 'JOB_EXPIRED', updated_at = NOW()
    WHERE status = 'pending' AND expires_at < NOW()
    RETURNING id;
END;
$$ LANGUAGE plpgsql;

-- Detect stuck jobs
CREATE OR REPLACE FUNCTION public.detect_stuck_jobs()
RETURNS TABLE(stuck_job_id UUID, stuck_duration INTERVAL) AS $$
BEGIN
    RETURN QUERY
    UPDATE public.job_queue
    SET status = 'failed', completed_at = NOW(),
        error_message = 'Job stuck in processing state',
        error_code = 'JOB_TIMEOUT', updated_at = NOW()
    WHERE status = 'processing'
      AND started_at < NOW() - INTERVAL '30 minutes'
    RETURNING id, NOW() - started_at;
END;
$$ LANGUAGE plpgsql;

-- =================================================================================
-- SECTION 6: STRIPE WEBHOOK FUNCTIONS
-- =================================================================================

-- Log webhook event
CREATE OR REPLACE FUNCTION public.log_stripe_webhook_event(
    p_stripe_event_id TEXT,
    p_event_type TEXT,
    p_event_data JSONB
) RETURNS UUID AS $$
DECLARE
    v_event_id UUID;
    v_existing_id UUID;
BEGIN
    SELECT id INTO v_existing_id FROM public.stripe_webhook_events WHERE stripe_event_id = p_stripe_event_id;
    IF v_existing_id IS NOT NULL THEN RETURN v_existing_id; END IF;
    
    INSERT INTO public.stripe_webhook_events (stripe_event_id, event_type, event_data, processed, retry_count)
    VALUES (p_stripe_event_id, p_event_type, p_event_data, false, 0)
    RETURNING id INTO v_event_id;
    RETURN v_event_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Mark webhook processed
CREATE OR REPLACE FUNCTION public.mark_webhook_processed(
    p_stripe_event_id TEXT,
    p_error_message TEXT DEFAULT NULL
) RETURNS VOID AS $$
BEGIN
    UPDATE public.stripe_webhook_events
    SET processed = (p_error_message IS NULL),
        processed_at = CASE WHEN p_error_message IS NULL THEN NOW() ELSE NULL END,
        error_message = p_error_message,
        retry_count = retry_count + 1, updated_at = NOW()
    WHERE stripe_event_id = p_stripe_event_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Retry failed webhooks
CREATE OR REPLACE FUNCTION public.retry_failed_webhooks(p_max_retries INT DEFAULT 3)
RETURNS TABLE(event_id UUID, stripe_event_id TEXT, event_type TEXT, retry_count INT) AS $$
BEGIN
    RETURN QUERY
    SELECT id, whe.stripe_event_id, whe.event_type, whe.retry_count
    FROM public.stripe_webhook_events whe
    WHERE processed = false AND retry_count < p_max_retries
      AND created_at > NOW() - INTERVAL '24 hours'
    ORDER BY created_at ASC LIMIT 100;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Cleanup old webhook events
CREATE OR REPLACE FUNCTION public.cleanup_old_webhook_events(p_days_old INT DEFAULT 90)
RETURNS INT AS $$
DECLARE
    v_deleted_count INT;
BEGIN
    DELETE FROM public.stripe_webhook_events
    WHERE processed = true
      AND processed_at < NOW() - (p_days_old || ' days')::INTERVAL;
    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
    RETURN v_deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =================================================================================
-- SECTION 7: STRIPE CACHE FUNCTIONS
-- =================================================================================

-- Cache Stripe data
CREATE OR REPLACE FUNCTION public.cache_stripe_data(
    p_cache_key TEXT,
    p_data JSONB,
    p_ttl_seconds INT DEFAULT 3600
) RETURNS VOID AS $$
BEGIN
    INSERT INTO public.cache_store (key, value, category, expires_at)
    VALUES (p_cache_key, p_data, 'stripe', NOW() + (p_ttl_seconds || ' seconds')::INTERVAL)
    ON CONFLICT (key) DO UPDATE
    SET value = EXCLUDED.value, expires_at = EXCLUDED.expires_at, updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get cached Stripe data
CREATE OR REPLACE FUNCTION public.get_cached_stripe_data(p_cache_key TEXT)
RETURNS JSONB AS $$
DECLARE
    v_cached_data JSONB;
BEGIN
    SELECT value INTO v_cached_data FROM public.cache_store
    WHERE key = p_cache_key AND category = 'stripe'
      AND (expires_at IS NULL OR expires_at > NOW());
    RETURN v_cached_data;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Invalidate Stripe cache
CREATE OR REPLACE FUNCTION public.invalidate_stripe_cache(p_pattern TEXT DEFAULT '%')
RETURNS INT AS $$
DECLARE
    v_deleted_count INT;
BEGIN
    DELETE FROM public.cache_store WHERE category = 'stripe' AND key LIKE p_pattern;
    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
    RETURN v_deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Webhook-triggered cache invalidation
CREATE OR REPLACE FUNCTION public.invalidate_stripe_cache_from_webhook(
    p_event_type TEXT,
    p_object_id TEXT
) RETURNS VOID AS $$
BEGIN
    CASE p_event_type
        WHEN 'product.created', 'product.updated', 'product.deleted' THEN
            PERFORM invalidate_stripe_cache('stripe:products');
            PERFORM invalidate_stripe_cache('stripe:product:' || p_object_id);
        WHEN 'price.created', 'price.updated', 'price.deleted' THEN
            PERFORM invalidate_stripe_cache('stripe:prices');
            PERFORM invalidate_stripe_cache('stripe:price:' || p_object_id);
        WHEN 'customer.subscription.created', 'customer.subscription.updated', 'customer.subscription.deleted' THEN
            PERFORM invalidate_stripe_cache('stripe:subscription:' || p_object_id);
        WHEN 'customer.updated', 'customer.deleted' THEN
            PERFORM invalidate_stripe_cache('stripe:customer:' || p_object_id);
        ELSE NULL;
    END CASE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =================================================================================
-- SECTION 8: TRIGGERS
-- =================================================================================

-- Real-time job status notifications
CREATE OR REPLACE FUNCTION public.notify_job_status_change()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM pg_notify(
        'job_status_changed',
        json_build_object(
            'job_id', NEW.id, 'user_id', NEW.user_id, 'job_type', NEW.job_type,
            'status', NEW.status, 'progress_percent', NEW.progress_percent,
            'progress_message', NEW.progress_message, 'error_message', NEW.error_message,
            'error_code', NEW.error_code, 'result', NEW.result, 'updated_at', NEW.updated_at
        )::text
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER job_status_change_notify
AFTER INSERT OR UPDATE OF status, progress_percent, progress_message, result
ON public.job_queue FOR EACH ROW EXECUTE FUNCTION public.notify_job_status_change();

CREATE TRIGGER trg_stripe_webhook_updated_at BEFORE UPDATE ON public.stripe_webhook_events 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- =================================================================================
-- SECTION 9: ROW LEVEL SECURITY
-- =================================================================================

ALTER TABLE public.job_queue ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.job_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.stripe_webhook_events ENABLE ROW LEVEL SECURITY;

CREATE POLICY job_queue_select_own ON public.job_queue FOR SELECT USING (user_id = auth.uid());
CREATE POLICY job_queue_insert_own ON public.job_queue FOR INSERT WITH CHECK (user_id = auth.uid());
CREATE POLICY job_queue_update_own ON public.job_queue FOR UPDATE USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid() AND status = 'cancelled');
CREATE POLICY job_queue_service_all ON public.job_queue FOR ALL USING (auth.jwt()->>'role' = 'service_role');

CREATE POLICY job_log_select_own ON public.job_log FOR SELECT USING (
    EXISTS (SELECT 1 FROM public.job_queue WHERE job_queue.id = job_log.job_id AND job_queue.user_id = auth.uid())
);
CREATE POLICY job_log_insert_service ON public.job_log FOR INSERT WITH CHECK (auth.jwt()->>'role' = 'service_role');

CREATE POLICY stripe_webhook_service_all ON public.stripe_webhook_events FOR ALL TO service_role USING (true) WITH CHECK (true);
CREATE POLICY stripe_webhook_admin_view ON public.stripe_webhook_events FOR SELECT TO authenticated USING (
    EXISTS (SELECT 1 FROM public.user_role WHERE user_role.user_id = auth.uid() AND user_role.role = 'admin')
);

-- =================================================================================
-- SECTION 10: GRANTS & PERMISSIONS
-- =================================================================================

GRANT SELECT ON public.job_type TO authenticated;
GRANT ALL ON public.job_queue TO authenticated, service_role;
GRANT ALL ON public.job_log TO service_role;
GRANT SELECT ON public.job_log TO authenticated;
GRANT SELECT ON public.stripe_webhook_events TO authenticated;
GRANT ALL ON public.stripe_webhook_events TO service_role;

GRANT EXECUTE ON FUNCTION public.create_job TO authenticated;
GRANT EXECUTE ON FUNCTION public.update_job_progress TO service_role;
GRANT EXECUTE ON FUNCTION public.start_job TO service_role;
GRANT EXECUTE ON FUNCTION public.complete_job TO service_role;
GRANT EXECUTE ON FUNCTION public.fail_job TO service_role;
GRANT EXECUTE ON FUNCTION public.cancel_job TO authenticated;
GRANT EXECUTE ON FUNCTION public.add_job_log TO service_role;
GRANT EXECUTE ON FUNCTION public.get_user_jobs TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_job_logs TO authenticated;
GRANT EXECUTE ON FUNCTION public.find_or_create_job TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_cached_job_result TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_job_queue_stats TO authenticated;
GRANT EXECUTE ON FUNCTION public.log_stripe_webhook_event TO service_role;
GRANT EXECUTE ON FUNCTION public.mark_webhook_processed TO service_role;
GRANT EXECUTE ON FUNCTION public.retry_failed_webhooks TO service_role;
GRANT EXECUTE ON FUNCTION public.cleanup_old_webhook_events TO service_role;
GRANT EXECUTE ON FUNCTION public.cache_stripe_data TO service_role;
GRANT EXECUTE ON FUNCTION public.get_cached_stripe_data TO service_role, authenticated;
GRANT EXECUTE ON FUNCTION public.invalidate_stripe_cache TO service_role;
GRANT EXECUTE ON FUNCTION public.invalidate_stripe_cache_from_webhook TO service_role;

-- =================================================================================
-- MODULE VERIFICATION
-- =================================================================================

DO $$
BEGIN
    RAISE NOTICE 'âœ… Module 006: Async Infrastructure - COMPLETE';
    RAISE NOTICE '   Tables: 4 (job_type, job_queue, job_log, stripe_webhook_events)';
    RAISE NOTICE '   Indexes: 20 (11 on job_queue + 4 on job_log + 5 on webhooks)';
    RAISE NOTICE '   Functions: 24 (16 job + 4 webhook + 4 cache)';
    RAISE NOTICE '   RLS Policies: 7';
    RAISE NOTICE '';
    RAISE NOTICE 'ðŸ§ª Test this module:';
    RAISE NOTICE '   1. Create job: SELECT create_job(auth.uid(), ''sync_youtube'', ''{}''::jsonb)';
    RAISE NOTICE '   2. Check job status: SELECT * FROM get_user_jobs(auth.uid())';
    RAISE NOTICE '   3. Simulate webhook: SELECT log_stripe_webhook_event(''evt_test'', ''customer.created'', ''{}'')';
    RAISE NOTICE '   4. Test deduplication: Call find_or_create_job() twice with same params';
    RAISE NOTICE '   5. Test caching: Call get_cached_job_result() after job completes';
    RAISE NOTICE '';
    RAISE NOTICE 'ðŸš€ Performance Features:';
    RAISE NOTICE '   - 11 optimized indexes on job_queue (composite, partial, GIN)';
    RAISE NOTICE '   - Job deduplication (5-min window)';
    RAISE NOTICE '   - Result caching (1-hour TTL)';
    RAISE NOTICE '   - Rate limiting (10 concurrent jobs/user)';
    RAISE NOTICE '   - Stripe webhook idempotency';
    RAISE NOTICE '   - Auto-retry with exponential backoff';
    RAISE NOTICE '';
    RAISE NOTICE 'ðŸŽ‰ ALL 7 MODULES COMPLETE!';
    RAISE NOTICE '   Total Tables: 36';
    RAISE NOTICE '   Total Functions: 27+';
    RAISE NOTICE '   Total Indexes: 80+';
    RAISE NOTICE '   Total RLS Policies: 35+';
    RAISE NOTICE '';
    RAISE NOTICE 'âž¡ï¸  Next: Apply modules in order (000-006) and test each feature';
END $$;
